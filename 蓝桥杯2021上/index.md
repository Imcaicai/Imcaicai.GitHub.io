# 【蓝桥杯】2021题解(上)


## 1 【填空】卡片

### 题目

小蓝有很多数字卡片，每张卡片上都是数字 0 到 9。小蓝准备用这些卡片来拼一些数，他想从 1 开始拼出正整数，每拼一个，就保存起来，卡片就不能用来拼其它数了。小蓝想知道自己能从 1 拼到多少。

例如，当小蓝有 30 张卡片，其中 0 到 9 各 3 张，则小蓝可以拼出 1 到 10，但是拼 11 时卡片 1 已经只有一张了，不够拼出 11。

现在小蓝手里有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1 拼到多少？

### 答题总结

⏰解题耗时：20min	📌正确率：1/2	🎯难度：💡

- 【计算一个整数各位上的数字】：当 `i/10!=0` 时，不断取出 `i%10` 。

### 解析

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
	
	int a[10]={2021,2021,2021,2021,2021,2021,2021,2021,2021,2021};	// 每个数字还剩的卡片数
	for(int i=1;;i++){
		int t=i/10, s=i%10;
		while(t){
			if(a[s]<=0){
				cout<< i-1;
				return 0;
			}
			else	a[s]--;
			s=t%10;
			t=t/10;
		}
		
		if(a[s]<=0){		
			cout<<i-1;
			return 0;
		}
		else	a[s]--;		// 这里还是 a[s]--，不是 a[t]！ 
	} 
	
	return 0;
}
```

## 2 【填空】空间

### 题目

小蓝准备用 256MB 的内存空间开一个数组，数组的每个元素都是 32 位 二进制整数，如果不考虑程序占用的空间和维护内存需要的辅助空间，请问 256MB 的空间可以存储多少个 32 位二进制整数？

### 答题总结

⏰解题耗时：3min	📌正确率：1/1	🎯难度：💡

### 解析

$256*2^{20}÷32 = 67108864$

（真的会有这么简单的题目吗。。。）

## 3 【填空】路径

### 题目

小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图 中的最短路径。小蓝的图由 2021 个结点组成，依次编号 1 至 2021。

对于两个不同的结点 a, b，如果 a 和 b 的差的绝对值大于 21，则两个结点 之间没有边相连；如果 a 和 b 的差的绝对值小于等于 21，则两个点之间有一条 长度为 a 和 b 的最小公倍数的无向边相连。

例如：结点 1 和结点 23 之间没有边相连；结点 3 和结点 24 之间有一条无 向边，长度为 24；结点 15 和结点 25 之间有一条无向边，长度为 75。

请计算，结点 1 和结点 2021 之间的最短路径长度是多少。

### 答题总结

⏰解题耗时：35min	📌正确率：1/2	🎯难度：💡

- 二维数组太大容易引起报错：`program received signal sigsegv, segmentation fault.` （本题中用 `int g\[2022][2022];` 就报错了QAQ）

### 解析

🟠 这题是典型的【动态规划】。用 dp[j] 来记录点 1到点 j 的最小距离，初始化为一个不可能的取值：-1。

🟡 由题目定义，当 j∈[ 2, 22 ] 时，点 1 到点 j 的最小距离就是他们的最大公倍数 j 。

🟢 当 j∈[23, 2021] 时，点 1 到点 j 没有直接边，因此路径 ( 1, j ) 只能由中间点 i 实现，且点 i 到点 j 有直接边。即： `dp[j]=min(dp[j], dp[i]+gbs(i,j))，i ∈[ j-21, j-1 ]`

🔵 求 (a, b) 的最小公倍数：考虑大数，将大数挨个乘1倍，直到这个数能被小数整除。

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

int gbs(int a,int b){				// 求 a b 的最小公倍数 
	int c=max(a,b),t=c,d=min(a,b);
	while(c%d)
		c+=t;
	return c;
} 

int main(){
	int dp[2022];
	for(int j=0;j<=2021;j++)		// 1 到每个点都初始化为一个不可能的取值 
		dp[j]=-1;
	for(int j=2;j<=22;j++)			// 1 到附近的 21 个点的最小值就是这个点的值 
		dp[j]=j;
	for(int j=23;j<=2021;j++){
		for(int i=j-21;i<j;i++){
			if(dp[j]==-1)
				dp[j]=dp[i]+gbs(i,j);
			else dp[j]=min(dp[j], dp[i]+gbs(i,j));
		}
	}
	
	cout<<dp[2021];
	return 0;
}
```

## 4 【填空】ASC

### 题目

已知大写字母 A 的 ASCII 码为 65，请问大写字母 L 的 ASCII 码是多少？

### 答题总结

⏰解题耗时：1min	📌正确率：1/1	🎯难度：💡

### 解析

```c++
cout<< 'L'-'A'+65;
```

（离谱的题目。。。。。。。）

## 5 【填空】相乘

### 题目

小蓝发现，他将 1 至 1000000007 之间的不同的数与 2021 相乘后再求除以 1000000007 的余数，会得到不同的数。 小蓝想知道，能不能在 1 至 1000000007 之间找到一个数，与 2021 相乘后 再除以 1000000007 后的余数为 999999999。如果存在，请在答案中提交这个数； 如果不存在，请在答案中提交 0。

### 答题总结

⏰解题耗时：20min	📌正确率：1/1	🎯难度：💡

- 整数问题常用【取模】

### 解析

这道题看起来很吓人，其实只需要取模分析就好，要注意整数的范围是 **-2147483648 ~ 2147483647** ，因此题目的数据不能直接计算。

🟠 分析题目的两个大数： `1000000007 = 2021×494804...1123，999999999 = 2021×494804...1115`

🟡 题目要求的公式为： `a×2021 = b×1000000007 + 999999999` ，根据 a 的范围容易得出 **b<2021** ，且 **左边能被 2021 整除** ，突破点在于 **找到能使右边被 2021 整除的 b** 。

🟢 得到 `b = 35` ，此时不能直接用右边除 2021 得到 a，否则整数计算时会溢出，我们把式子分解来考虑：`a×2021 = 35×1000000007+999999999 = 35×(494804×2021+1123)+(494804×2021+1115)`

等式右边有 `36×494804+(35×1123+1115)/2021 = 17812964` 个 2021，因此 `a=17812964` 。

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

int main(){
	
	int s=1000000007%2021,t=999999999%2021;
	int p=1000000007/2021,q=999999999/2021;
	int b=0,x,y,a;
	for(int i=0;i<2021;i++){
		if((i*s+t)%2021==0){
			b=i;
			break;
		}
	}
	
	cout<<p<<' '<<s<<endl<<q<<' '<<t<<endl;
	cout<<b<<endl;
	a=36*494804+(35*1123+1115)/2021;
	cout<<a;
	
	return 0;
}
```


