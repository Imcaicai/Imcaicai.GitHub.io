# 【蓝桥杯】2021题解(上)


⏰总用时：			🎯正确率：

| 题号   | 时间 | 得分 | 难度 | 备注                                                         |
| ------ | ---- | ---- | ---- | ------------------------------------------------------------ |
| **1**  | 20   | ❌    | 🌕    | 🔸【计算一个整数各位上的数字】：当 `i/10!=0` 时，不断取出 `i%10` 。 |
| **2**  | 3    | ✅    | 🌕    |                                                              |
| **3**  | 35   | ❌    | 🌕    | 🔸 二维数组太大容易引起报错：`program received signal sigsegv, segmentation fault.` （本题中用 `int g[2022][2022];` 就报错了QAQ） |
| **4**  | 1    | ✅    | 🌕    |                                                              |
| **5**  | 20   | ✅    | 🌕    | 🔸 整数问题常用【取模】                                       |
| **6**  | 40   | ❌    | 🌓    |                                                              |
| **7**  | 35   | ✅    | 🌓    | 🔸 【动态规划】考虑上一跳从哪来，而不是下一跳往哪去<br/>🔸 用数组 r[9]、c[9] 表示横纵坐标偏移的 9 种情况 |
| **8**  | 15   | ✅    | 🌕    | 🔹 注意题目给的数据范围，应该用 long long，用 int 无法通过样例 |
| **9**  | 25   | ❌    | 🌓    |                                                              |
| **10** | 45   | 40   | 🌓    |                                                              |

## 1 【填空】卡片

### 题目

小蓝有很多数字卡片，每张卡片上都是数字 0 到 9。小蓝准备用这些卡片来拼一些数，他想从 1 开始拼出正整数，每拼一个，就保存起来，卡片就不能用来拼其它数了。小蓝想知道自己能从 1 拼到多少。

例如，当小蓝有 30 张卡片，其中 0 到 9 各 3 张，则小蓝可以拼出 1 到 10，但是拼 11 时卡片 1 已经只有一张了，不够拼出 11。

现在小蓝手里有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1 拼到多少？

### 解析

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
	
	int a[10]={2021,2021,2021,2021,2021,2021,2021,2021,2021,2021};	// 每个数字还剩的卡片数
	for(int i=1;;i++){
		int t=i/10, s=i%10;
		while(t){
			if(a[s]<=0){
				cout<< i-1;
				return 0;
			}
			else	a[s]--;
			s=t%10;
			t=t/10;
		}
		
		if(a[s]<=0){		
			cout<<i-1;
			return 0;
		}
		else	a[s]--;		// 这里还是 a[s]--，不是 a[t]！ 
	} 
	
	return 0;
}
```

## 2 【填空】空间

### 题目

小蓝准备用 256MB 的内存空间开一个数组，数组的每个元素都是 32 位 二进制整数，如果不考虑程序占用的空间和维护内存需要的辅助空间，请问 256MB 的空间可以存储多少个 32 位二进制整数？

### 解析

$256*2^{20}÷32 = 67108864$

（真的会有这么简单的题目吗。。。）

## 3 【填空】路径

### 题目

小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图 中的最短路径。小蓝的图由 2021 个结点组成，依次编号 1 至 2021。

对于两个不同的结点 a, b，如果 a 和 b 的差的绝对值大于 21，则两个结点 之间没有边相连；如果 a 和 b 的差的绝对值小于等于 21，则两个点之间有一条 长度为 a 和 b 的最小公倍数的无向边相连。

例如：结点 1 和结点 23 之间没有边相连；结点 3 和结点 24 之间有一条无 向边，长度为 24；结点 15 和结点 25 之间有一条无向边，长度为 75。

请计算，结点 1 和结点 2021 之间的最短路径长度是多少。

### 解析

🟠 这题是典型的【动态规划】。用 dp[j] 来记录点 1到点 j 的最小距离，初始化为一个不可能的取值：-1。

🟡 由题目定义，当 j∈[ 2, 22 ] 时，点 1 到点 j 的最小距离就是他们的最大公倍数 j 。

🟢 当 j∈[23, 2021] 时，点 1 到点 j 没有直接边，因此路径 ( 1, j ) 只能由中间点 i 实现，且点 i 到点 j 有直接边。即： `dp[j]=min(dp[j], dp[i]+gbs(i,j))，i ∈[ j-21, j-1 ]`

🔵 求 (a, b) 的最小公倍数：考虑大数，将大数挨个乘1倍，直到这个数能被小数整除。

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

int gbs(int a,int b){				// 求 a b 的最小公倍数 
	int c=max(a,b),t=c,d=min(a,b);
	while(c%d)
		c+=t;
	return c;
} 

int main(){
	int dp[2022];
	for(int j=0;j<=2021;j++)		// 1 到每个点都初始化为一个不可能的取值 
		dp[j]=-1;
	for(int j=2;j<=22;j++)			// 1 到附近的 21 个点的最小值就是这个点的值 
		dp[j]=j;
	for(int j=23;j<=2021;j++){
		for(int i=j-21;i<j;i++){
			if(dp[j]==-1)
				dp[j]=dp[i]+gbs(i,j);
			else dp[j]=min(dp[j], dp[i]+gbs(i,j));
		}
	}
	
	cout<<dp[2021];
	return 0;
}
```

## 4 【填空】ASC

### 题目

已知大写字母 A 的 ASCII 码为 65，请问大写字母 L 的 ASCII 码是多少？

### 解析

```c++
cout<< 'L'-'A'+65;
```

（离谱的题目。。。。。。。）

## 5 【填空】相乘

### 题目

小蓝发现，他将 1 至 1000000007 之间的不同的数与 2021 相乘后再求除以 1000000007 的余数，会得到不同的数。 小蓝想知道，能不能在 1 至 1000000007 之间找到一个数，与 2021 相乘后 再除以 1000000007 后的余数为 999999999。如果存在，请在答案中提交这个数； 如果不存在，请在答案中提交 0。

### 解析

这道题看起来很吓人，其实只需要取模分析就好，要注意整数的范围是 **-2147483648 ~ 2147483647** ，因此题目的数据不能直接计算。

🟠 分析题目的两个大数： `1000000007 = 2021×494804...1123，999999999 = 2021×494804...1115`

🟡 题目要求的公式为： `a×2021 = b×1000000007 + 999999999` ，根据 a 的范围容易得出 **b<2021** ，且 **左边能被 2021 整除** ，突破点在于 **找到能使右边被 2021 整除的 b** 。

🟢 得到 `b = 35` ，此时不能直接用右边除 2021 得到 a，否则整数计算时会溢出，我们把式子分解来考虑：`a×2021 = 35×1000000007+999999999 = 35×(494804×2021+1123)+(494804×2021+1115)`

等式右边有 `36×494804+(35×1123+1115)/2021 = 17812964` 个 2021，因此 `a=17812964` 。

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

int main(){
	
	int s=1000000007%2021,t=999999999%2021;
	int p=1000000007/2021,q=999999999/2021;
	int b=0,x,y,a;
	for(int i=0;i<2021;i++){
		if((i*s+t)%2021==0){
			b=i;
			break;
		}
	}
	
	cout<<p<<' '<<s<<endl<<q<<' '<<t<<endl;
	cout<<b<<endl;
	a=36*494804+(35*1123+1115)/2021;
	cout<<a;
	
	return 0;
}
```

## 6 【填空】货物摆放

### 题目

小蓝有一个超大的仓库，可以摆放很多货物。

现在，小蓝有 n 箱货物要摆放在仓库，每箱货物都是规则的正方体。小蓝规定了长、宽、高三个互相垂直的方向，每箱货物的边都必须严格平行于长、宽、高。小蓝希望所有的货物最终摆成一个大的长方体。即在长、宽、高的方向上分别堆 L、W、H 的货物,满足 n=L×W×H。

例如，当 n=4 时，有以下 6 种方案：1×1×4、1×2×2、1×4×1、2×1×2、2×2×1、4×1×1。

请问，当 n=2021041820210418 （注意有 16 位数字）时，总共有多少种方案？

### 解析



```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

set<long long> s;				// 存储 2021041820210418 的所有因数 

// 计算出  2021041820210418 的所有因数 
void geti(long long x){			
	long y=pow(x,0.5);
	for(long i=1;i<=y;i++){		// 只用遍历到 y，因为另一半是对称的				
		if(x%i==0){
			s.insert(i);
			s.insert(x/i);		// 要记得把对称的另一半数字也添上去			
		}
	}
	return;
} 

int main(){
	// 1. 计算出 2021041820210418 所有因数 
	long long num=2021041820210418;
	int cnt=0;
	geti(num);			
	
	// 2. 遍历因数
	cout<<s.size()<<endl;
	for(const auto &i:s){
		for(const auto &j:s){
			if(num%(i*j)==0)	// 只要 i*j 还是 num 的因数就符合 
				cnt++;
		}
	}
	
	cout<<cnt;
	return 0;
}
```

## 7 跳跃

### 题目

小蓝在一个 n行 m 列的方格图中玩一个游戏。开始时，小蓝站在方格图的左上角，即第 1 行第 1 列。小蓝可以在方格图上走动，走动时，如果当前在第 r 行第 c 列，他不能走到行号比 r 小的行，也不能走到列号比 c 小的列。同时，他一步走的直线距离不超过 3。

例如，如果当前小蓝在第 3 行第 5 列，他下一步可以走到第 3 行第 6 列、第 3 行第 7 列、第 3 行第 8 列、第 4 行第 5 列、第 4 行第 6 列、第 4 行第 7 列、第 5 行第 5 列、第 5 行第 6 列、第 6 行第 5 列之一。

小蓝最终要走到第 n 行第 m 列。

在图中，有的位置有奖励，走上去即可获得，有的位置有惩罚，走上去就要接受惩罚。奖励和惩罚最终抽象成一个权值，奖励为正，惩罚为负。

小蓝希望，从第 1 行第 1 列走到第 n 行第 m 列后，总的权值和最大。请问最大是多少？

**输入描述**

输入的第一行包含两个整数 n, m，表示图的大小。

接下来 n 行，每行 m 个整数，表示方格图中每个点的权值。

其中，$1≤ n ≤100，−10^4≤ 权值 ≤10^4$ 。

**输出描述**

输出一个整数，表示最大权值和。

### 解析

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

int main(){
	
	int n,m;
	cin>>n>>m; 
	int dp[n][m]; 
	int r[9]={-3,-2,-2,-1,-1,-1,0,0,0};	// 记录横坐标可能偏移的情况 
	int c[9]={0,-1,0,-2,-1,0,-3,-2,-1}; // 记录纵坐标可能偏移的情况 
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			cin>>dp[i][j];				// 输入数据
			if(i==0 && j==0) continue;	// dp[0][0] 就是本身
			
			int max=INT_MIN;			// 用 INT_MIN 表示最小整数 
			for(int k=0;k<9;k++){		// 列举上一跳 9 种可能的情况 
				if(i+r[k]>=0 && j+c[k]>=0 && max<dp[i+r[k]][j+c[k]])
					max= dp[i+r[k]][j+c[k]];
			}
			dp[i][j]+=max; 
		}
	} 
	
	cout<<dp[n-1][m-1]<<endl;
	return 0;
}
```

## 8 时间显示

### 题目

小蓝要和朋友合作开发一个时间显示的网站。在服务器上，朋友已经获取了当前的时间，用一个整数表示，值为从 1970 年 1 月 1 日 00:00:00 到当前时刻经过的毫秒数。

现在，小蓝要在客户端显示出这个时间。小蓝不用显示出年月日，只需要显示出时分秒即可，毫秒也不用显示，直接舍去即可。

给定一个用整数表示的时间，请将这个时间对应的时分秒输出。

**输入描述**

输入一行包含一个整数，表示时间。

**输出描述**

输出时分秒表示的当前时间，格式形如 `HH:MM:SS`，其中 `HH` 表示时，值为 0 到 23，`MM` 表示分，值为 0 到 59，`SS` 表示秒，值为 0 到 59。时、分、秒 不足两位时补前导 0。

### 解析

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

int main(){
	
	long long x,h,m,s,d=24*60*60;
	cin>>x;
	
	x=x/1000%d;	// 换成 1 天内的秒数 
	s=x%60;			// 秒 
	m=x/60%60;		// 分
	h=x/3600;		// 时 
	if(h<10)	cout<<'0'<<h<<':';
	else	cout<<h<<':';
	if(m<10)	cout<<'0'<<m<<':';
	else	cout<<m<<':';
	if(s<10)	cout<<'0'<<s;
	else	cout<<s;

	return 0;
}
```

## 9 砝码称重

### 题目

你有一架天平和 N 个砝码，这 N 个砝码重量依次是 $W_1, W_2,...W_N$ 。

请你计算一共可以称出多少种不同的重量？ 注意砝码可以放在天平两边。

**输入格式**

输入的第一行包含一个整数 N 。

第二行包含  N 个整数：$W_1, W_2,...W_N$ 。

**输出格式**

输出一个整数代表答案。

### 解析

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

int main(){
	
	int n,w[100],x,y;
	set<int> s;
	set<int>::iterator it;	// 注意这个写法！ 
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>w[i];
	}
	
	s.insert(0);
	for(int i=0;i<n;i++){
		set<int> t=s;
		for(it=t.begin();it!=t.end();it++){	// 用迭代器循环时不能修改 set 内元素！ 
			s.insert(*it + w[i]);
			s.insert(abs(*it - w[i]));
		}
	} 

	cout<<s.size()-1<<endl;
	return 0;
}
```


