# 【蓝桥杯】2021题解


⏰总用时：			🎯总分：

| 题号   | 时间 | 结果 | 满分 | 难度 | 备注                                                         |
| ------ | ---- | ---- | ---- | ---- | ------------------------------------------------------------ |
| **1**  | 20   | ❌    | 5    | 🌕    | 🔸【计算一个整数各位上的数字】：当 `i/10!=0` 时，不断取出 `i%10` 。 |
| **2**  |      |      | 5    |      |                                                              |
| **3**  | 40   | ❌    | 10   | 🌓    | 🔸 整数问题常用【取模】                                       |
| **4**  | 35   | ❌    | 10   | 🌕    | 🔸 二维数组太大容易引起报错：`program received signal sigsegv, segmentation fault.` （本题中用 `int g[2022][2022];` 就报错了QAQ） |
| **5**  |      |      | 10   |      |                                                              |
| **6**  | 25   | ❌    | 15   | 🌓    |                                                              |
| **7**  |      |      | 20   |      |                                                              |
| **8**  |      |      | 20   |      |                                                              |
| **9**  |      |      | 25   |      |                                                              |
| **10** |      |      | 25   |      |                                                              |

## 1 【填空】卡片

### 题目

小蓝有很多数字卡片，每张卡片上都是数字 0 到 9。小蓝准备用这些卡片来拼一些数，他想从 1 开始拼出正整数，每拼一个，就保存起来，卡片就不能用来拼其它数了。小蓝想知道自己能从 1 拼到多少。

例如，当小蓝有 30 张卡片，其中 0 到 9 各 3 张，则小蓝可以拼出 1 到 10，但是拼 11 时卡片 1 已经只有一张了，不够拼出 11。

现在小蓝手里有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1 拼到多少？

### 解析

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
	
	int a[10]={2021,2021,2021,2021,2021,2021,2021,2021,2021,2021};	// 每个数字还剩的卡片数
	for(int i=1;;i++){
		int t=i/10, s=i%10;
		while(t){
			if(a[s]<=0){
				cout<< i-1;
				return 0;
			}
			else	a[s]--;
			s=t%10;
			t=t/10;
		}
		
		if(a[s]<=0){		
			cout<<i-1;
			return 0;
		}
		else	a[s]--;		// 这里还是 a[s]--，不是 a[t]！ 
	} 
	
	return 0;
}
```

## 2 【填空】直线

### 题目



### 解析



## 3 【填空】货物摆放

### 题目

小蓝有一个超大的仓库，可以摆放很多货物。

现在，小蓝有 n 箱货物要摆放在仓库，每箱货物都是规则的正方体。小蓝规定了长、宽、高三个互相垂直的方向，每箱货物的边都必须严格平行于长、宽、高。小蓝希望所有的货物最终摆成一个大的长方体。即在长、宽、高的方向上分别堆 L、W、H 的货物,满足 n=L×W×H。

例如，当 n=4 时，有以下 6 种方案：1×1×4、1×2×2、1×4×1、2×1×2、2×2×1、4×1×1。

请问，当 n=2021041820210418 （注意有 16 位数字）时，总共有多少种方案？

### 解析

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

set<long long> s;				// 存储 2021041820210418 的所有因数 

// 计算出  2021041820210418 的所有因数 
void geti(long long x){			
	long y=pow(x,0.5);
	for(long i=1;i<=y;i++){		// 只用遍历到 y，因为另一半是对称的				
		if(x%i==0){
			s.insert(i);
			s.insert(x/i);		// 要记得把对称的另一半数字也添上去			
		}
	}
	return;
} 

int main(){
	// 1. 计算出 2021041820210418 所有因数 
	long long num=2021041820210418;
	int cnt=0;
	geti(num);			
	
	// 2. 遍历因数
	cout<<s.size()<<endl;
	for(const auto &i:s){
		for(const auto &j:s){
			if(num%(i*j)==0)	// 只要 i*j 还是 num 的因数就符合 
				cnt++;
		}
	}
	
	cout<<cnt;
	return 0;
}
```

## 4 【填空】路径

### 题目

小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图 中的最短路径。小蓝的图由 2021 个结点组成，依次编号 1 至 2021。

对于两个不同的结点 a, b，如果 a 和 b 的差的绝对值大于 21，则两个结点 之间没有边相连；如果 a 和 b 的差的绝对值小于等于 21，则两个点之间有一条 长度为 a 和 b 的最小公倍数的无向边相连。

例如：结点 1 和结点 23 之间没有边相连；结点 3 和结点 24 之间有一条无 向边，长度为 24；结点 15 和结点 25 之间有一条无向边，长度为 75。

请计算，结点 1 和结点 2021 之间的最短路径长度是多少。

### 解析

🟠 这题是典型的【动态规划】。用 dp[j] 来记录点 1到点 j 的最小距离，初始化为一个不可能的取值：-1。

🟡 由题目定义，当 j∈[ 2, 22 ] 时，点 1 到点 j 的最小距离就是他们的最大公倍数 j 。

🟢 当 j∈[23, 2021] 时，点 1 到点 j 没有直接边，因此路径 ( 1, j ) 只能由中间点 i 实现，且点 i 到点 j 有直接边。即： `dp[j]=min(dp[j], dp[i]+gbs(i,j))，i ∈[ j-21, j-1 ]`

🔵 求 (a, b) 的最小公倍数：考虑大数，将大数挨个乘1倍，直到这个数能被小数整除。

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

int gbs(int a,int b){				// 求 a b 的最小公倍数 
	int c=max(a,b),t=c,d=min(a,b);
	while(c%d)
		c+=t;
	return c;
} 

int main(){
	int dp[2022];
	for(int j=0;j<=2021;j++)		// 1 到每个点都初始化为一个不可能的取值 
		dp[j]=-1;
	for(int j=2;j<=22;j++)			// 1 到附近的 21 个点的最小值就是这个点的值 
		dp[j]=j;
	for(int j=23;j<=2021;j++){
		for(int i=j-21;i<j;i++){
			if(dp[j]==-1)
				dp[j]=dp[i]+gbs(i,j);
			else dp[j]=min(dp[j], dp[i]+gbs(i,j));
		}
	}
	
	cout<<dp[2021];
	return 0;
}
```

## 5 回路计数

### 题目



### 解析



## 6 砝码称重

### 题目

你有一架天平和 N 个砝码，这 N 个砝码重量依次是 $W_1, W_2,...W_N$ 。

请你计算一共可以称出多少种不同的重量？ 注意砝码可以放在天平两边。

**输入格式**

输入的第一行包含一个整数 N 。

第二行包含  N 个整数：$W_1, W_2,...W_N$ 。

**输出格式**

输出一个整数代表答案。

### 解析

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

int main(){
	
	int n,w[100],x,y;
	set<int> s;
	set<int>::iterator it;	// 注意这个写法！ 
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>w[i];
	}
	
	s.insert(0);
	for(int i=0;i<n;i++){
		set<int> t=s;
		for(it=t.begin();it!=t.end();it++){	// 用迭代器循环时不能修改 set 内元素！ 
			s.insert(*it + w[i]);
			s.insert(abs(*it - w[i]));
		}
	} 

	cout<<s.size()-1<<endl;
	return 0;
}
```

## 7 异或数列

### 题目



**输入格式**



**输出格式**



### 解析



## 8 左孩子右兄弟

### 题目



**输入格式**



**输出格式**



### 解析



## 9 括号序列

### 题目



**输入格式**



**输出格式**



### 解析



## 10 分果果

### 题目



**输入格式**



**输出格式**



### 解析


