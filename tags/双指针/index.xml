<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>双指针 - Tag - 菜菜的秘密花园</title>
        <link>https://imcaicai.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
        <description>双指针 - Tag - 菜菜的秘密花园</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 05 Jan 2023 17:58:47 &#43;0800</lastBuildDate><atom:link href="https://imcaicai.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="self" type="application/rss+xml" /><item>
    <title>数组链表-双指针技巧解决数组题</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E8%A7%A3%E5%86%B3%E6%95%B0%E7%BB%84%E9%A2%98/</link>
    <pubDate>Thu, 05 Jan 2023 17:58:47 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E8%A7%A3%E5%86%B3%E6%95%B0%E7%BB%84%E9%A2%98/</guid>
    <description><![CDATA[在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：左右指针和快慢指针。所谓左右指针，就是两个指针相向而行或者相背而行；而所谓快慢指针，就是两个指针同向而行。
1 快慢指针技巧 题目 力扣 26. 删除有序数组中的重复项
给你一个 升序排列 的数组 nums ，请你**原地** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。
将最终结果插入 nums 的前 k 个位置后返回 k 。
不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
解析 我们让慢指针 slow 走在后面，快指针 fast 走在前面探路，找到⼀个不重复的元素就赋值给 slow 并让 slow 前进⼀步。 这样，就保证了 nums[0..slow] 都是无重复的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组去重之后的结果。 代码实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public int removeDuplicates(int[] nums) { if(nums.]]></description>
</item>
<item>
    <title>数组链表-双指针技巧解决链表题</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E9%A2%98/</link>
    <pubDate>Sat, 31 Dec 2022 00:08:35 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E9%A2%98/</guid>
    <description><![CDATA[1 合并两个有序链表 题目 力扣 21. 合并两个有序链表
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例：
1 2  输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]   解析 这题比较简单，直接用 while 循环每次比较 p1 和 p2 的大小，把较小的节点接到结果链表上，如图所示：
 虚拟头节点技巧  通过虚拟头节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。 当你需要创造⼀条新链表的时候，可以使⽤虚拟头结点简化边界情况的处理。   最后通过 p.next = n1; 将剩余的节点全都复制过去，不需要使用 while 循环一条一条复制。  代码实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { // 虚拟头结点  ListNode p = new ListNode(), res = p; ListNode n1 = list1, n2 = list2; while(n1!]]></description>
</item>
</channel>
</rss>
