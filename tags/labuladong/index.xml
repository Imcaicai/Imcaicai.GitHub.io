<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>labuladong - Tag - 菜菜的秘密花园</title>
        <link>https://imcaicai.github.io/tags/labuladong/</link>
        <description>labuladong - Tag - 菜菜的秘密花园</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 18 Mar 2023 00:04:04 &#43;0800</lastBuildDate><atom:link href="https://imcaicai.github.io/tags/labuladong/" rel="self" type="application/rss+xml" /><item>
    <title>【动态规划】动态规划核心框架</title>
    <link>https://imcaicai.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/</link>
    <pubDate>Sat, 18 Mar 2023 00:04:04 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/</guid>
    <description><![CDATA[🔴 【动态规划三要素】重叠子问题、最优子结构、状态转移方程
🟢 【思维框架】明确 base case → 明确「状态」→ 明确「选择」 → 定义 dp 数组/函数的含义。
🔵
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # ⾃顶向下递归的动态规划 def dp(状态1, 状态2, ...): for 选择 in 所有可能的选择: # 此时的状态已经因为做了选择⽽改变 result = 求最值(result, dp(状态1, 状态2, ...)) return result # ⾃底向上迭代的动态规划 # 初始化 base case dp[0][0][...] = base case # 进⾏状态转移 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for .]]></description>
</item>
<item>
    <title>【数据结构设计】实现一个计算器</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E5%99%A8/</link>
    <pubDate>Thu, 16 Mar 2023 21:12:41 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E5%99%A8/</guid>
    <description><![CDATA[1 题目 实现一个计算器，功能如下：
1、输入一个字符串，可以包含 + - * /、数字、括号以及空格，你的算法返回运算结果。
2、要符合运算法则，括号的优先级最高，先乘除后加减。
3、除号是整数除法，无论正负都向 0 取整（5/2=2，-5/2=-2）。
4、可以假定输入的算式⼀定合法，且计算过程不会出现整型溢出，不会出现除数为 0 的意外情况。
2 解析 2.1 字符串转整数 1 2 3 4 5 6  // 把字符串s转为整数n int n = 0; for (int i = 0; i &lt; s.size(); i++) { char c = s[i]; n = 10 * n + (c - &#39;0&#39;); }   ❗❗❗ 注意 (c - &lsquo;0&rsquo;) 的括号不能省略，否则可能造成整型溢出。
2.2 处理加减法 🟠 先给第⼀个数字加⼀个默认符号 +，变成 +1-12+3。]]></description>
</item>
<item>
    <title>【数据结构设计】常数时间查找数组元素</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/</link>
    <pubDate>Thu, 16 Mar 2023 19:13:59 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/</guid>
    <description><![CDATA[1 题目 力扣 380. O(1) 时间插入、删除和获取随机元素
实现RandomizedSet 类：
 RandomizedSet() 初始化 RandomizedSet 对象 bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。 bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。 int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。  你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。
2 解析 考虑题目的两个要求：
🔴 插入、删除、查询随机元素的时间复杂度必须都是 O(1)。 想到使用 STL 中的 map 结构。
🟡 getRandom() 必须等概率的返回随机元素。 那么底层必须用数组实现，且数组是紧凑的，这样就可以直接生成随机数作为数组索引。
🟢 综合考虑以上2个条件：在 O(1) 的时间删除数组中的某⼀个元素 val，可以先把这个元素交换到数组的尾部，然后再 pop 掉。而交换两个元素需要知道索引，故用哈希表存储每个元素及其索引。
代码实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  class RandomizedSet { public: // 存储元素的值  vector&lt;int&gt; ve; // 键是元素值，值是元素在ve中的索引  unordered_map&lt;int, int&gt; ma; RandomizedSet() { } bool insert(int val) { // 若 val 不存在，则插入并返回true  if(ma.]]></description>
</item>
<item>
    <title>【数据结构设计】LRU算法</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1lru%E7%AE%97%E6%B3%95/</link>
    <pubDate>Tue, 17 Jan 2023 13:37:09 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1lru%E7%AE%97%E6%B3%95/</guid>
    <description><![CDATA[1 题目 力扣 146. LRU 缓存
请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：
 LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。  函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
2 解析 2.1 LRU算法设计 由于 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：
 🔴 cache 中的元素必须有时序，以区分最近使用的和久未使用的数据]]></description>
</item>
<item>
    <title>【队列和栈】单调队列解决滑动窗口问题</title>
    <link>https://imcaicai.github.io/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</link>
    <pubDate>Sun, 15 Jan 2023 10:56:33 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</guid>
    <description><![CDATA[【单调队列】主要是为了解决以下场景：
 给你一个数组 window，已知其最值为 A，如果给 window 中添加⼀个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；但如果要从 window 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历 window 中的所有元素重新寻找新的最值。
 可以使用 优先级队列 来动态寻找最值，通过创建一个大（小）顶堆，可以很快拿到最大（小）值。
但优先级队列无法满足标准队列结构【先进先出】的时间顺序，因为优先级队列底层利用二叉堆对元素进行动态排序，元素的出队顺序是元素的大小顺序，和入队的先后顺序完全没有关系。
而【单调队列】结构，既能够维护队列元素【先进先出】的时间顺序，又能够正确维护队列中所有元素的最值。
1 题目 力扣 239. 滑动窗口最大值
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回 滑动窗口中的最大值 。
2 解析 2.1 搭建解题框架 🟧 普通队列的标准 API：
1 2 3 4 5 6  class Queue{ // enqueue 操作，在队尾加⼊元素 n 	void push(int n); // dequeue 操作，删除队头元素 	void pop(); }   🟨 【单调队列】的 API：]]></description>
</item>
<item>
    <title>【队列和栈】单调栈解决下一个更大元素</title>
    <link>https://imcaicai.github.io/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E5%8D%95%E8%B0%83%E6%A0%88%E8%A7%A3%E5%86%B3%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
    <pubDate>Sat, 14 Jan 2023 12:02:02 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E5%8D%95%E8%B0%83%E6%A0%88%E8%A7%A3%E5%86%B3%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
    <description><![CDATA[1 单调栈模板 题目 输入一个数组 nums，请你返回⼀个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。
解析 🔴 把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列。如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的下⼀个更大元素，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。
🟡 for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。
🟢 while 循环是把两个「高个子」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的下一个更大元素了。
🔵 这个算法的复杂度只有 O(n)。 总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop一次，没有任何冗余操作。
图解：
代码实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  int[] nextGreaterElement(int[] nums) { int n = nums.length; // 存放答案的数组 	int[] res = new int[n]; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); // 倒着往栈⾥放 	for (int i = n - 1; i &gt;= 0; i--) { // 判定个⼦⾼矮 	while (!]]></description>
</item>
<item>
    <title>【队列和栈】详解3道括号题</title>
    <link>https://imcaicai.github.io/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E8%AF%A6%E8%A7%A33%E9%81%93%E6%8B%AC%E5%8F%B7%E9%A2%98/</link>
    <pubDate>Thu, 12 Jan 2023 17:30:44 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E8%AF%A6%E8%A7%A33%E9%81%93%E6%8B%AC%E5%8F%B7%E9%A2%98/</guid>
    <description><![CDATA[1.1 判断有效括号串 题目 给定一个只包括 '('，')' 的字符串 s ，判断字符串是否有效。即每个右括号 ')' 的左边必须有⼀个左括号 '(' 和它匹配。
解析 用一个变量 left 记录 '(' 相对于 ')' 的数量，遇到 '(' 就 +1，遇到 ')' 就 -1。如果最后 left==0，则括号串有效，否则无效。并且，如果中间出现 left 数量为负，则说明有 ')' 出现在 '(' 之前，也为无效。
代码实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  bool isValid(string str) { // 待匹配的左括号数量 	int left = 0; for (int i = 0; i &lt; str.]]></description>
</item>
<item>
    <title>【数组链表】递归反转链表</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
    <pubDate>Thu, 12 Jan 2023 17:08:24 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
    <description><![CDATA[1 递归反转整个链表 题目 力扣 206. 反转链表
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
示例：
1 2  输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]   解析 图解：
代码实现：
1 2 3 4 5 6 7 8 9 10  public ListNode reverseList(ListNode head) { if(head==null || head.next==null){ return head; } ListNode last=reverseList(head.next); head.next.next=head; head.next=null; return last; }   2个注意点：
🟡 递归函数要有 base case，如果链表为空或者只有⼀个节点的时候，反转结果就是它自己。
1 2 3  if (head == null || head.next == null) { return head; }   🟢 当链表递归反转之后，新的头结点是 last，而之前的 head 变成了最后⼀个节点，别忘了链表的末尾要指向 null。]]></description>
</item>
<item>
    <title>【数组链表】田忌赛马背后的算法决策</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E8%83%8C%E5%90%8E%E7%9A%84%E7%AE%97%E6%B3%95%E5%86%B3%E7%AD%96/</link>
    <pubDate>Sun, 08 Jan 2023 15:48:52 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E8%83%8C%E5%90%8E%E7%9A%84%E7%AE%97%E6%B3%95%E5%86%B3%E7%AD%96/</guid>
    <description><![CDATA[题目 力扣 870. 优势洗牌
给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。
返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。
解析 这道题类似于【田忌赛马】，只不过马的数量变多了，精髓在于【打得过就打，打不过就拿自己的垃圾和对方的精锐互换 】。我们先分析【田忌赛马】，考虑以下 3 点：
🟡 如果田忌的 1 号选手 &lt; 齐王的 1 号选手，显然应该用田忌垫底的马送人头，降低对方的战斗力。
🟢 如果田忌的 1 号选手 &lt; 齐王的 1 号选手，则应该直接让两者相比。
🟠 当出现第二种情况时，即 T1 &gt; Q1 时，要不要节约战斗力，用 T2 对抗 Q1？
答案是不需要。假设 T2 &gt; Q1，那么不论换不换 T1，T1 和 T2 都能对抗所有的 Q，这种节约毫无意义。
根据以上思路，我们的策略是：
将齐王和田忌的马按照战斗力排序，然后按照排名一一对比。如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力。
结合已学过的双指针技巧，代码实现如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution { public int[] advantageCount(int[] nums1, int[] nums2) { int n=nums1.]]></description>
</item>
<item>
    <title>【数组链表】二分查找算法</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link>
    <pubDate>Sat, 07 Jan 2023 11:59:28 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid>
    <description><![CDATA[二分思维的精髓就是：通过已知信息尽可能多地收缩搜索空间，从而增加穷举效率，快速找到目标。
1 二分查找框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14  int binarySearch(int[] nums, int target) { int left = 0, right = ...; while(...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] &lt; target) { left = ... } else if (nums[mid] &gt; target) { right = ... } } return .]]></description>
</item>
</channel>
</rss>
