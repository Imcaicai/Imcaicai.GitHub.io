# 【蓝桥杯】2017题解


⏰总用时：170/240			🎯总分：32.5/100

| 题号   | 时间 | 结果 | 满分 | 难度 | 备注                                      |
| ------ | ---- | ---- | ---- | ---- | ----------------------------------------- |
| **1**  | 45   | ✅    | 5    | 🌕    | 🔸 计算完一定要带入样例检验，漏加了 1 ❗❗❗  |
| **2**  | 15   | ❌    | 11   | 🌓    |                                           |
| **3**  | 5    | ❌    | 13   | 🌓    |                                           |
| **4**  | 5    | ❌    | 17   | 🌓    |                                           |
| **5**  | 5    | ✅    | 7    | 🌕    |                                           |
| **6**  | 10   | ✅    | 9    | 🌕    | 🔹 注意 scanf，printf 格式化输入输出的使用 |
| **7**  | 25   | ❌    | 19   | 🌓    | 🔸 模拟<br/>🔸                              |
| **8**  | 5    | ❌    | 21   | 🌓    | 🔹 并查集（不过没用）                      |
| **9**  | 30   | 50%  | 23   | 🌓    |                                           |
| **10** | 25   | ❌    | 25   | 🌓    |                                           |

## 1 【填空】迷宫

### 题目

1/1+1/2+1/4+1/8+......

每项是前一项的一半，如果一共有 20 项,求这个和是多少，结果用分数表示出来。

类似：3/2，当然，这只是加了前 2 项而已。分子分母要求互质。

### 解析

注意检验，前面还加了一个 1 ❗❗❗

```c++
#include <bits/stdc++.h>
using namespace std;

char c[10][10];
bool d[10][10];							// 存储该坐标是否能出去
bool v[10][10];							// 存储该坐标是否已访问过		

bool dfs(int x,int y){
	if(v[x][y]){						
		if(d[x][y])	return true;		// 已知当前坐标是否可以走出迷宫，直接返回 
		else return false;				// 如果有回路绕回来，也是直接返回 false 
	}						
	
	
	v[x][y]=true;						// 先标记该点已访问过 
	switch(c[x][y]){					// 未知，则继续朝着坐标的方向走 
		case 'U':			
			if(x<=0)					// 可以出去，则返回并记录 
				return d[x][y]=true;					
			else						// 否则继续递归 
				return d[x][y]=dfs(x-1,y);		

		case 'D':
			if(x>=9)					 
				return d[x][y]=true;	
			else					
				return d[x][y]=dfs(x+1,y);

		case 'L':
			if(y<=0)					 
				return d[x][y]=true;	
			else			
				return d[x][y]=dfs(x,y-1);
				
		case 'R':
			if(y>=9)					 
				return d[x][y]=true;	
			else					
				return d[x][y]=dfs(x,y+1);

	}
}

int main(){

	for(int i=0;i<10;i++){			// 输入 
		for(int j=0;j<10;j++)
			cin>>c[i][j];
	}
	
	for(int i=0;i<10;i++){			// 深搜，确定每个坐标是否能走出迷宫 
		for(int j=0;j<10;j++)
			dfs(i,j);
	}
	
	int cnt=0;
	for(int i=0;i<10;i++){			// 统计能走出迷宫的个数 
		for(int j=0;j<10;j++)
			cnt+=d[i][j];
	}
	cout<<cnt;
	
	return 0;
} 
```

## 2 【填空】跳蚱蜢

### 题目

整个 20 世纪（1901 年 1 月 1 日至 2000 年 12 月 31 日之间），一共有多少个星期一？(不要告诉我你不知道今天是星期几)

### 解析

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int ans,sum=0;
    for(int i=1901;i<=2000;i++){                // 计算总天数，最后一天是星期六 
        if((i%4==0 && i%100!=0) || i%400==0)    // 这是闰年 
            sum+=366;
        else    sum+=365;                        // 这不是闰年 
    }
    
    ans=sum/7;
    if(sum%7==5)    ans++;
    cout<<ans;
    
    return 0;
}
```

## 3 【填空】魔方状态

### 题目

如下的 10 行数据，每行有 10 个整数，请你求出它们的乘积的末尾有多少个零？

```
5650 4542 3554 473 946 4114 3871 9073 90 4329 
2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 
9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 
1486 5722 3135 1170 4014 5510 5120 729 2880 9019 
2049 698 4582 4346 4427 646 9742 7340 1230 7683 
5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 
6701 6645 1671 5978 2704 9926 295 3125 3878 6785 
2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 
3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 
689 5510 8243 6114 337 4096 8199 7313 3685 211 
```

### 解析

🟠 注意 `10=2*5` ，只用看这100个数中因数 2 和 5 的个数分别为多少，不用乘出来。

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int x=0,y=0,t,ans;
    for(int i=0;i<100;i++){
        cin>>t;
        while(t%2==0){        // 计算 2 的个数 
            x++;t/=2;
        }
        while(t%5==0){        // 计算 5 的个数 
            y++;t/=5;
        }
    }
    
    ans=min(x,y);
    cout<<ans;
    
    return 0;
}
```

## 4 【填空】方格分割

### 题目

到 X 星球旅行的游客都被发给一个整数，作为游客编号。

X 星的国王有个怪癖，他只喜欢数字 3,5 和 7。国王规定，游客的编号如果只含有因子：3,5,7 就可以获得一份奖品。

我们来看前 10 个幸运数字是： 3, 5, 7, 9, 15, 21, 25, 27, 35, 45 。因而第 11 个幸运数字是： 49 。

小明领到了一个幸运数字 59084709587505，他去领奖的时候，人家要求他准确地说出这是第几个幸运数字，否则领不到奖品。

请你帮小明计算一下，59084709587505 是第几个幸运数字。

### 解析

🟠 直接遍历，注意每次遍历后 i, j, k 分别乘 3, 5, 7 。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main(){
	ll n=59084709587505;
	int cnt=0;
	for(ll i=1;i<=n;i*=3){
		for(ll j=1;i*j<=n;j*=5){
			for(ll k=1;i*j*k<=n;k*=7)
				cnt++;
		}
	}
	cout<<cnt-1;		// 要减去 1 
	return 0;
} 
```

## 5 【填空】字母组串

### 题目

如下的程序会在控制台绘制分形图。

当 n=1,2,3 的时候，输出如下： 请仔细分析程序，并填写划线部分缺少的代码。

![img1](/img/蓝桥杯/6.png)

### 解析

```c++
#include <stdio.h>
#include <stdlib.h>

void show(char* buf, int w){
    int i,j;
    for(i=0; i<w; i++){
        for(j=0; j<w; j++){
            printf("%c", buf[i*w+j]==0? ' ' : 'o');
        }
        printf("\n");
    }
}

void draw(char* buf, int w, int x, int y, int size){
    if(size==1){
        buf[y*w+x] = 1;
        return;
    }
    
    int n = size/3 ; //填空
    draw(buf, w, x, y, n);
    draw(buf, w, x-n, y ,n);
    draw(buf, w, x+n, y ,n);
    draw(buf, w, x, y-n ,n);
    draw(buf, w, x, y+n ,n);
}

int main()
{
    int N ;
        scanf("%d",&N);
    int t = 1;
    int i;
    for(i=0; i<N; i++) t *= 3;            // 最长的一行圆的个数 
    
    char* buf = (char*)malloc(t*t);
    for(i=0; i<t*t; i++) buf[i] = 0;    // 初始化 
    
    draw(buf, t, t/2, t/2, t);
    show(buf, t);
    free(buf);
    
    return 0;
}
```

## 6 最大公共子串

### 题目

不久后小 h 的女朋友去中东交换。小 h 并不知道中东与北京的时差。但是小 h 得到了女朋友来回航班的起降时间。小 h 想知道女朋友的航班飞行时间是多少。

对于一个可能跨时区的航班，给定来回程的起降时间。假设飞机来回飞行时间相同，求飞机的飞行时间。

**输入描述**

一个输入包含多组数据。

输入第一行为一个正整数 n ，表示输入数据组数。

每组数据包含两行，第一行为去程的 起降 时间，第二行为回程的 起降 时间。

**输出描述**

对于每一组数据输出一行一个时间 hh:mm:ss，表示飞行时间为 hh 小时 mm 分 ss 秒。

注意，当时间为一位数时，要补齐前导零。如三小时四分五秒应写 03:04:05。

### 解析

🟠 注意 scanf，printf 格式化输入输出的使用

```c++
#include <bits/stdc++.h>
using namespace std;

int getTime(){
    int h1,h2,m1,m2,s1,s2,d=0,t;        
    // 注意这种格式化输入方法！！！ 
    scanf("%d:%d:%d %d:%d:%d (+%d)",&h1,&m1,&s1,&h2,&m2,&s2,&d);
    // 都换算成秒，不能用时分秒分别计算，容易出错！！！ 
    t=d*24*60*60+(h2*3600+m2*60+s2)-(h1*3600+m1*60+s1);
    return t; 
}

int main(){
    int n,t1,t2,t;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        t1=getTime();
        t2=getTime();
        t=(t1+t2)/2;
        printf("%02d:%02d:%02d\n",t/3600,t/60%60,t%60);
    }
    
    return 0;
}
```

## 7 正则问题

### 题目

"饱了么"外卖系统中维护着 N 家外卖店，编号 1 ∼ N。每家外卖店都有 一个优先级，初始时 (0 时刻) 优先级都为 0。

每经过 1 个时间单位，如果外卖店没有订单，则优先级会减少 1，最低减 到 0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 2。

如果某家外卖店某时刻优先级大于 5，则会被系统加入优先缓存中；如果 优先级小于等于 3，则会被清除出优先缓存。

给定 T 时刻以内的 M 条订单信息，请你计算 T 时刻时有多少外卖店在优 先缓存中?

**输入描述**

输入第一行包含两个整数 N 和 K 。

第二行包含 N 个整数 $A_1, A_2,...,A_N$ 。

**输出描述**

输出一行包含一个整数表示答案。

### 解析

```c++
#include <bits/stdc++.h>
using namespace std;

struct u{
    map<int,int> t;        					// 表示用户有订单的时刻和订单数量 
};
u user[100005];

int main(){
    int n,m,t,ts,id,cnt=0;
    map<int,int>::iterator it;
    cin>>n>>m>>t;
    for(int i=0;i<m;i++){        			// 输入订单信息 
        scanf("%d %d",&ts,&id);
        (user[id].t[ts])++;
    }
    
    for(int i=1;i<=n;i++){
        int s=0,t1=0,t2=0,flag=0;
        for(it=user[i].t.begin();it!=user[i].t.end();it++){
            t1=t2;t2=it->first;
            if(s-(t2-t1-1) <0)    s=0;		// 注意这里的 s 应该减去多少！！！ 
            else s-=(t2-t1-1);
            if(s>5)    flag=1;				// 注意这里也要判断一下！！！ 
            if(s<=3 && flag)    flag=0;
            
            s+=(it->second*2);
            if(s>5)    flag=1;
            if(s<=3 && flag)    flag=0;
        }
        if(user[i].t.count(t)!=1)
            s-=(t-t2);
        if(s>5)    flag=1;
        if(s<=3 && flag)    flag=0;
        if(flag)    cnt++;
    } 
    
    cout<<cnt;
    return 0;
}
```

## 8 包子凑数

### 题目

给定一个长度为 n 的数组 $A=[A_1,A_2,...A_n]$ ，数组中有可能有重复出现的整数。

现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改 $A_2,A_3...A_n$ 。

当修改 $A_i$ 时，小明会检查 $A_i$ 是否在 $A_1...A_{i-1}$ 中出现过。如果出现过，则小明会给 $A_i$ 加上 1 ；如果新的 $A_i$ 仍在之前出现过，小明会持续给 $A_i$ 加 1 ，直 到 $A_i$ 没有在 $A_1...A_{i-1}$ 中出现过。

当 $A_n$ 也经过上述修改之后，显然 A 数组中就没有重复的整数了。

现在给定初始的 A 数组，请你计算出最终的 A 数组。

**输入描述**

第一行包含一个整数 n 。

第二行包含 n 个整数 $A_1,A_2,...A_n$ 。

其中，$1≤ n ≤ 10^5, 1≤ A_i ≤ 10^6$ 。

**输出描述**

输出 n 个整数，依次是最终的 $A_1,A_2,...A_n$ 。

### 解析

🟠 用 map 等 STL 容器容易超时，这道题不用可以过 80% 的样例，用了只能过 40% 。非必要不使用❗❗❗

🟡 **dev 数组开大会爆栈 ❗❗❗ 可以用 static 或者修改分配的栈大小 ❗❗❗**

🟢 过80%的简单代码（会超时）：

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
	int n,t;
	static int b[1000005]={0};	// 注意这里不用static会爆栈！！！ 
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>t;
		if(b[t]==1){			// 找到第一个没用被用掉的 t 
			while(b[t]==1)		// 这里是超时的原因！！！ 
				t++;
		}
		
		b[t]=1;					// 这里多了个 "=" 
		cout<<t<<" ";
	}
	return 0;
} 
```

🟣 优化后的代码：

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
	int n,t;
	static int a[1000005]={0};
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>t;
		while(a[t]!=0){
			a[t]++;			// 用 a[t] 记录 t 出现的次数！！！ 
			t+=(a[t]-1);	// 加速遍历！！！ 
		}
		a[t]++;
		cout<<t<<" ";
	}
	
	return 0;
} 
```

## 9 分巧克力

### 题目

糖果店的老板一共有 m 种口味的糖果出售。为了方便描述，我们将 m 种口味编号 1∼ m。

小明希望能品尝到所有口味的糖果。遗憾的是老板并不单独出售糖果，而是 k 颗一包整包出售。

幸好糖果包装上注明了其中 k 颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。

给定 n 包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果。

**输入描述**

第一行包含三个整数 n,m,k。

接下来 n 行每行 k 个整数 $t_1,t_2,...t_k$ ，代表一包糖果的口味。

其中，1≤n≤100, 1≤m≤20, 1≤k≤20, $1≤t_i≤m$ 。

**输出描述**

输出一个整数表示答案。如果小明无法品尝所有口味，输出 −1。

### 解析

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
	int n,m,k,t;
	set<int> s;						// 用于判断 n 包糖的总种类数 
	cin>>n>>m>>k;
	int a[105];						// 每包糖的状态
	static int dp[1<<20+1];			// 每个状态所需的最小包数 
	
	// 1. 输入并存储每包糖的状态 
	for(int i=1;i<=n;i++){			// 遍历每包糖
		int x=0,y;
		for(int j=1;j<=k;j++){		// 遍历一包糖的每颗糖 
			cin>>y;
			x |= (1<<(y-1));		// 加上这颗糖的状态 
			s.insert(y);			// 更新总种类 
		}
		a[i]=x; 
	}
	
	// 2. 判断总共是否有 m 种糖，如果没有则输出 -1 并退出
	if(s.size()<m){
		cout<< -1;	return 0;
	} 
	
	// 3. 动态规划找出每个状态所需的最小包数
	fill(dp,dp+(1<<20)+1,0xffff);	// 初始化 
	dp[0]=0;						// 设置 base case 
	t=(1<<m)-1;						// m 个 1 
	for(int i=1;i<=n;i++){
		for(int j=t;j>=0;j--)		// 遍历每个状态，决定要不要加这包糖 
			dp[j|a[i]]=min(dp[j|a[i]],dp[j]+1);
	}
	
	cout<<dp[t];
	return 0;
}
```

## 10 油漆面积

