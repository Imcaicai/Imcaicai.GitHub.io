[{"categories":["计算机网络"],"content":"最近在复习计算机网络考试，于是按照《计算机网络自顶向下方法》（原书第7版）一书梳理了1-7章的知识，其中第五章的内容合并到第四章中了。 ","date":"2022-12-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:0","tags":["计算机网络"],"title":"计算机网络知识总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["计算机网络"],"content":"1 计算机网络和因特网 ","date":"2022-12-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:1:0","tags":["计算机网络"],"title":"计算机网络知识总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["计算机网络"],"content":"2 应用层 ","date":"2022-12-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:2:0","tags":["计算机网络"],"title":"计算机网络知识总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["计算机网络"],"content":"3 运输层 ","date":"2022-12-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:3:0","tags":["计算机网络"],"title":"计算机网络知识总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["计算机网络"],"content":"4 网络层 ","date":"2022-12-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:4:0","tags":["计算机网络"],"title":"计算机网络知识总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["计算机网络"],"content":"6 链路层和局域网 ","date":"2022-12-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:5:0","tags":["计算机网络"],"title":"计算机网络知识总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["计算机网络"],"content":"7 无线网络和局域网 ","date":"2022-12-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:6:0","tags":["计算机网络"],"title":"计算机网络知识总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["深度学习"],"content":"本文为论文 Label Embedding Online Hashing for Cross-Modal 的阅读笔记。 论文下载：https://doi.org/10.1145/3394171.3413971 ","date":"2022-11-18","objectID":"/lemon/:0:0","tags":["深度学习"],"title":"Label Embedding Online Hashing for Cross-Modal Retrieval","uri":"/lemon/"},{"categories":["深度学习"],"content":"1 简介 学习散列，作为最著名的近似近邻搜索技术之一，近年来吸引了很多人的注意。它旨在将高维实值特征映射到紧凑的二进制编码，同时保留原始空间中的相似性。然后，可以用XOR操作在Hamming空间中进行搜索，效率高，存储成本低。 许多跨模态散列方法已经被提出并取得了很好的性能。但大多数现有的方法通过批处理学习二进制代码或哈希函数。即在学习过程前，所有的训练数据都可用。这将产生以下问题： 实际数据通常以流方式收集，有新数据到来时，批处理方法需要对所有数据重新训练 → 效率低 训练集随训练时间变大 → 计算成本高 为了解决这些问题，在线散列被提出，但仍存在问题： 大多数在线散列方法是为单模态检索设计的，很难直接扩展到跨模态检索。少数在线跨模态散列模型被提出，但性能较差，因为异质模态之间的关联性难以捕捉。 只根据新到达的数据更新散列函数，忽略了新旧数据间的相关性 → 丢失现有数据的信息 → 现有在线散列。 新数据到来时，哈希函数可以有效地重新训练，但哈希码必须对所有累积数据重构 → 更新方案低效。 离散优化大多采用松弛策略 → 量化误差大。 为了解决上述问题，这篇文章提出了一种新的监督下的跨模式检索的在线散列方法，即Label EMbedding ONline hashing，简称LEMON。本文的主要贡献总结如下： 提出了一种新的有监督的在线散列检索方法，即LEMON。 它通过一个标签嵌入框架来捕捉语义结构，其中包括标签相似性的保存和标签重构，从而得到更有辨识度的二进制码。 通过优化内积最小化问题将新旧数据的哈希码连接起来，解决了更新不平衡问题。 采用两步学习策略，有效地更新哈希函数和二进制码，同时保持旧数据库的哈希代码不可更改，使其计算复杂度仅与流数据的大小有关。 提出了一种迭代优化算法来离散地解决二进制优化问题，极大地减少 量化误差。 在三个基准数据集上的实验结果表明，LEMON在跨模式检索任务上优于一些先进的离线和在线散列方法，并且可以扩展到大规模数据集。 ","date":"2022-11-18","objectID":"/lemon/:1:0","tags":["深度学习"],"title":"Label Embedding Online Hashing for Cross-Modal Retrieval","uri":"/lemon/"},{"categories":["深度学习"],"content":"2 相关工作 现有工作存在的问题： 单模态：不能直接用于跨模态检索任务；必须在每一轮更新所有的二进制代码，效率非常低 多模态：不能跨模态检索 跨模态：不能充分利用原始特征、语义标签；不能很好地以流的方式来捕捉数据的相似性信息 单模态：查询和要检索的文档都只有一个模态（图像→图像） 多模态：查询和要检索的文档必须至少有一个模态相同（图像、文本→图像、文本） 跨模态：查询和要检索的文档模态不同（图像→文本） ","date":"2022-11-18","objectID":"/lemon/:2:0","tags":["深度学习"],"title":"Label Embedding Online Hashing for Cross-Modal Retrieval","uri":"/lemon/"},{"categories":["深度学习"],"content":"3 方法 ","date":"2022-11-18","objectID":"/lemon/:3:0","tags":["深度学习"],"title":"Label Embedding Online Hashing for Cross-Modal Retrieval","uri":"/lemon/"},{"categories":["深度学习"],"content":"3.1 Notations 假设每个样本由 $l$ 个模态组成。在第 $t$ 轮，一个新的数据块 $\\vec{X}^{(t)}$ 被添加到数据库中。常用变量的说明如下： 符号 意义 $\\vec{X}_m^{(t)}∈R^{d_m×n_t}$ 表示新数据块的第 $m$ 个模态，其中 $n_t$ 是新数据块的大小， $d_m$ 是特征维度。$m∈{1，2，…，l}$ $\\vec{L}^{(t)}∈R^{c×n_t}$ 新数据块的标签矩阵，其中 $c$ 是语义类别的数量 $\\tilde{X}^{(t)}$ 现有数据 $N_{t-1} = \\sum_{k=1}^{t-1} n_k$ 现有数据的大小，$N_t=N_{t-1} +n_t$ $\\tilde{L}^{(t)}∈R^{c×N_{t-1}}$ 现有数据的相应标签矩阵 $X^{(t)}_m=[\\tilde{X}^{(t)}_m,\\vec{X}_m^{(t)}]∈R^{d_m×N_t}$ 代表当前整个数据库 $L^{(t)}=[\\tilde{L}^{(t)},\\vec{L}^{(t)}]∈R^{c×N_t}$ 代表整个标签矩阵 $\\tilde{B}^{(t)}$ 现有数据的哈希码 $\\vec{B}^{(t)}$ 新数据的哈希码 我们的目标是学习所有模态的 $r$ 位统一哈希码$B^{(t)}=[\\tilde{B}^{(t)},\\vec{B}^{(t)}]∈R^{r×N_t}$，和第$m$ 个模态的哈希函数 $H_m^{(t)}(·)$。 本文采用了一个两步学习方案：首先学习现有样本和新数据的哈希码，再基于学习到的哈希码，进一步学习哈希函数。 ","date":"2022-11-18","objectID":"/lemon/:3:1","tags":["深度学习"],"title":"Label Embedding Online Hashing for Cross-Modal Retrieval","uri":"/lemon/"},{"categories":["深度学习"],"content":"3.2 Hash Codes Learning 算法整体伪代码： 3.2.1 Label Embedding 根据检索任务的目标，二进制代码应该保留实例的语义相似性。为了实现这一点，任务可以定义为以下的内积最小化问题： $$ min_{B(t)} ∥B^{(t)⊤}B^{(t)} − rS^{(t)}∥^2, s.t. B^{(t)} ∈ {−1, 1}^{r×N_t}\\tag{1} $$ $S_{(t)}$ 是语义相似度矩阵。如果第 $i$ 个实例和第 $j$ 个实例至少有一个共同的标签，则 $S^{(t)}_{ij} = 1$ ，否则 $S^{(t)}_{ij} = -1$ 。此方案存在的问题： 存储、计算成本大 不能表明细粒度的语义相似性，特别是对于多标签数据 为了解决上述问题，重新定义相似性矩阵，并通过二进制的哈希码保存。标签相似度矩阵如下： $$ S^{(t)} = 2U^{(t)⊤} U^{(t)} − 11^⊤\\tag{2} $$ 其中 $U^{(t)⊤}$ 是2规范化的标签矩阵，定义为 $u^{(t)}_i =l^{(t)}_i/∥l^{(t)}_i ∥$ ，而 $l^{(t)}_i$ 是 $L^{(t)}$ 的第 $i$ 列。 为了使 $S^{(t)}$ 能够用于在线场景，进一步将其改写为一个块状矩阵。$S_{oo}^{(t)}$，$S_{oc}^{(t)}$，$S_{co}^{(t)}$，$S_{cc}^{(t)}$分别是旧数据的成对相似度矩阵、旧新数据的相似度矩阵、旧新数据的相似度矩阵、新数据的成对相似性矩阵。 我们试图将更多的标签信息嵌入待学习的二进制码中。假设所有样本标签都可以从学习到的二进制码中重构。可以进一步定义以下优化问题： $$ min_{{B,P}^{(t)}} ∥L^{(t)} −P^{(t)}B^{(t)}∥^2+γ ∥P^{(t)}∥^2, s.t. B^{(t)} ∈ {−1, 1}^{r×N_t} \\tag{5} $$ 其中 $γ$ 是惩罚参数，$P^{(t)}∈R^{c×r}$ 是投影矩阵。合并(1)和(5)： $$ min_{{B,P}^{(t)}} α ∥B^{(t)⊤}B^{(t)} − rS^{(t)}∥^2+ β∥L^{(t)} −P^{(t)}B^{(t)}∥^2+βγ ∥P^{(t)}∥^2 \\tag{6} $$ 其中 $α$ 和 $β$ 是权衡参数。显然，上述方法通过保留标签的相似性、重建标签，可以将更多的语义信息嵌入二进制码中。此外，它通过最一致的语义标签来匹配异质性的模式，从而产生统一的二进制码，非常适用于在线学习。 3.2.2 Online Learning 理想情况下，我们希望保持 $\\tilde{B}^{(t)}$ 不变，只更新 $\\vec{B}^{(t)}$ 。将(3)代入(6)得： $$ min_{{B,P}^{(t)}} α ∥\\vec{B}^{(t)⊤}\\tilde{B}^{(t)} − rS_{co}^{(t)}∥^2+ α ∥\\tilde{B}^{(t)⊤}\\vec{B}^{(t)} − rS_{oc}^{(t)}∥^2 + α ∥\\vec{B}^{(t)⊤}\\vec{B}^{(t)} − rS_{cc}^{(t)}∥^2 + $$ $$ β∥\\vec{L}^{(t)} −P^{(t)}\\vec{B}^{(t)}∥^2+ β∥\\tilde{L}^{(t)} −P^{(t)}\\tilde{B}^{(t)}∥^2+βγ ∥P^{(t)}∥^2, \\tag{7} $$ 这个在线目标是由最初的批处理目标推导出来的，即公式(6)。包含 $S_{oo}^{(t)}$ 的项被切断，因为 $\\tilde{B}^{(t)}$ 不变。因此，它对传入的数据不太敏感，能够产生更多的鉴别性哈希码。通过上述目标函数，新数据之间的成对相似性被保留。更重要的是，新旧数据之间的关联性也被 $S_{oc}^{(t)}$ 或 $S_{co}^{(t)}$ 捕获。因此，公式(7)能将更多的相似性信息嵌入到二进制码中。 然而随着时间的积累，旧数据库的样本数量比新数据块的大得多，导致相似性矩阵 $S_{co}^{(t)}$ 稀疏且不平衡，大多数元素是负的。使用直接的离散优化可能会带来巨大的信息损失，因为硬二进制矩阵分解可能会偏向于保持不相似的信息而丢失相似的信息。为了解决这个问题，我们用一个实值 $V^{(t)}$ 来代替一个 $B^{(t)}$。类似地，有 $V^{(t)}=[\\tilde{V}^{(t)},\\vec{V}^{(t)}]$ 。为了减少 $B^{(t)}$ 和 $V^{(t)}$ 间的信息损失，引入一个正交旋转矩阵的正则化项：$R^{(t)}∈R^{r×r}$ 。为了使 $V^{(t)}$ 无偏，引入正交和平衡约束。目标函数成为以下函数： $$ min_{{\\vec{B},\\vec{V},P,R}^{(t)}} ∥\\vec{B}^{(t)}−R^{(t)}\\vec{V}^{(t)}∥^2+∥\\tilde{B}^{(t)}−R^{(t)}\\tilde{V}^{(t)}∥^2 + α ∥\\vec{V}^{(t)⊤}\\tilde{B}^{(t)} − rS_{co}^{(t)}∥^2+ $$ $$ α ∥\\tilde{V}^{(t)⊤}\\vec{B}^{(t)} − rS_{oc}^{(t)}∥^2 + α ∥\\vec{V}^{(t)⊤}\\vec{B}^{(t)} − rS_{cc}^{(t)}∥^2 + β∥\\vec{L}^{(t)} −P^{(t)}\\vec{V}^{(t)}∥^2+ $$ $$ β∥\\tilde{L}^{(t)} −P^{(t)}\\tilde{V}^{(t)}∥^2+βγ ∥P^{(t)}∥^2, \\tag{8} $$ 这样一来，二元约束只强加在一个被分解的变量上，而且避免了二元矩阵分解。 此外，实值 $V^{(t)}$ 比 $B^{(t)}$ 能更准确地捕捉语义信息，确保在相似性保存过程中可接受的信息损失，从而解决更新不平衡问题。此外，它仍然保留了离散的约束条件，并通过sign(·)操作有效地生成二进制哈希码。$V^{(t)}$ 在相似性空间和标签空间之间架起了桥梁。 3.2.3 Efficient Discrete Optimization 为了解决公式 (8) 的问题，我们提出了四步迭代优化算法，该算法有效地、不连续地生成哈希码。在每个步骤中，一个变量被更新，而其他变量被固定。 更新 $P^{(t)}$ 。令公式 (8) 关于 $P^{(t)}$ 的导数为零，得出 $P^{(t)}$ ： $$ P^{(t)} = C^{(t)}_1 (C^{(t)}_2 + γ I)^{−1} \\tag{9} $$ 更新 $\\vec{V}^{(t)}$ 。当Bfi(t)、P(t)、R(t)固定时，公式(8)可以被简化为： $$ max_{\\vec{V}^{(t)}} tr(Z\\vec{V}^{(t)}), s.t. \\vec{V}^{(t)}\\vec{V}^{(t)T} = n_tI, \\vec{V}^{(t)}1 = 0. \\tag{13} $$ 我们可以发现，方程(13)有一个封闭形式的最优解。记为 $J = I - \\frac{1}{nt} 11^⊤$。注意 $J$ 是实时计算的。然后，该问题可以通过对 ${ZJZ}^⊤$ 进行奇异值分解来解决： $$ {ZJZ}^⊤=\\left[\\begin{matrix}G \u0026 \\hat{G}\\end{matrix}\\right] \\left[\\begin{matrix}Ω \u0026 0 \\ 0 \u0026 0\\end{matrix}\\right] \\left[\\begin{matrix}G \u0026 \\hat{G}\\end{matrix}\\right]\\tag{16} $$ 这里，$Ω∈R^{r^′×r^′}$ 是正特征值的对角矩阵，$G∈R^{r×r^′}$ 是相应的特征向量。$\\hat{G}$ 是剩余的 $r - r^′$ 零特征值的特征向量。$r'$ 是 $ZJZ^⊤$ 的等级。通过对 $\\hat{G}$ 进行Gram-Schmidt处理，可以得到一个正交矩阵 $\\bar{G}∈R^{r×(r-r^′)}$。我们进一步表示 $Q = JZ^⊤GΩ^{-1/2}$，并生成一个随机的正交矩阵 $\\bar{Q}∈R^{n_t×(r-r^′)}$ 。如果 r′=r，$\\bar{G}$ 和 $\\bar{Q}$ 为空。则公式(13)的最优解是： $$ \\vec{V}^{(t)} = \\sqrt{n_t} \\left[\\begin{matrix}G \u0026 \\bar{G}\\end{matrix}\\right] \\left[\\begin{matrix}Q \u0026 \\bar{Q}\\end{matrix}\\right]^T.\\tag{17} $$ 更新 $\\vec{R}^{(t)}$ 。在除 $\\vec{R}^{(t)}$ 之外的所有变量固定的情况下，公式(8)变成经典的正交普鲁斯特问题，可以通过重度分解来解决： $$ C^{(t)}_5 = AΣ\\hat{A}^⊤,\\tag{18} $$ $$ C^{(t)}_5 = C^{(t-1)}_5+\\vec{B}^{(t)}\\vec{V}^{(t)T}, C^{(t-1)}_5=\\tilde{B}^{(t)}\\tilde{V}^{(t)T} .\\tag{19} $$ 得到 $R^{(t)}$ 的最佳解为： $$ R^{(t)} = A\\","date":"2022-11-18","objectID":"/lemon/:3:2","tags":["深度学习"],"title":"Label Embedding Online Hashing for Cross-Modal Retrieval","uri":"/lemon/"},{"categories":["深度学习"],"content":"3.3 Hash Functions Learning 获得统一的二进制码后，需要学习哈希函数来适应多种模式。为了达到这个目的，可以采用不同的模型，如线性回归、支持向量机、深度神经网络。我们在学到的二进制码的监督下，为每种模式训练一个线性回归模型。具体来说，给定学习的二进制码 $B^{(t)}$ 和第 $m$ 个模态的特征矩阵 $X^{(t)}_m$，线性映射模型可以通过解决以下问题被学习： $$ min_{W^{(t)}_m} ∥B^{(t)} − W^{(t)}_m X^{(t)}_m∥^2 + ξ ∥W^{(t)}_m∥^2,\\tag{24} $$ 其中 $ξ$ 是一个惩罚参数，$W^{(t)}_m$ 是映射矩阵。通过将公式 (25) 关于 $W^{(t)}_m$ 的导数设为零,得到最佳解： $$ W^{(t)}_m = H^{(t)}_m(F^{(t)}_m + ξ I)^{−1},\\tag{26} $$ $$ H^{(t)}_m = H^{(t-1)}_m+\\vec{B}^{(t)}\\vec{X}^{(t)T}_m, H^{(t-1)}_m=\\tilde{B}^{(t)}\\tilde{X}^{(t)T}_m, $$ $$ F^{(t)}_m = F^{(t-1)}_m+\\vec{X}^{(t)}\\vec{X}^{(t)T}_m, F^{(t-1)}_m=\\tilde{X}^{(t)}\\tilde{X}^{(t)T}_m .\\tag{27} $$ 此后，给定一个新的查询，我们可以取第 $m$ 个模态 $x_m∈R^{d_m}$，并通过以下哈希函数生成其哈希码： $$ H^{(t)}_m (x_m) = sign(W^{(t)}_mx_m).\\tag{28} $$ 训练过程的整体计算复杂度与新数据的大小 $n_t$ 呈线性关系，而与旧数据库的大小无关。因此，LEMON可以扩展到大规模的在线检索任务。 ","date":"2022-11-18","objectID":"/lemon/:3:3","tags":["深度学习"],"title":"Label Embedding Online Hashing for Cross-Modal Retrieval","uri":"/lemon/"},{"categories":["深度学习"],"content":"4 实验 为了评估LEMON的性能，我们在三个基准数据集上进行了广泛实验。 ","date":"2022-11-18","objectID":"/lemon/:4:0","tags":["深度学习"],"title":"Label Embedding Online Hashing for Cross-Modal Retrieval","uri":"/lemon/"},{"categories":["深度学习"],"content":"4.1 实施细节 在实现LEMON的过程中，我们首先对MIRFlickr-25K数据集进行了参数敏感性分析，当α和β为 1e4 时，LEMON取得最佳效果。此外我们观察到，参数对性能的影响并不显著。因此，为了简单起见，所有的数据集上都设置了相同的参数，即α=β=1e4。根据经验，$γ$ 和 $ξ$ 分别被设定为0.1和1。每一轮的迭代次数为5。 在实验中，我们进行了两种类型的跨模式检索任务。图像→文本和文本→图像。利用平均精度（MAP）和训练时间，来评估所有方法的性能。 ","date":"2022-11-18","objectID":"/lemon/:4:1","tags":["深度学习"],"title":"Label Embedding Online Hashing for Cross-Modal Retrieval","uri":"/lemon/"},{"categories":["深度学习"],"content":"4.2 结果分析 4.2.1 平均精度分析 MIRFlickr-25K数据集的结果如表1所示，展示了不同长度样例的MAP值。 不同方法的性能如下图所示： 可以得出： LEMON在所有情况下都持续优于其他方法，表明其在处理跨模式检索任务方面的有效性。 一般来说，离线基线（如DLFH和SCRATCH），比在线基线（如OCMH和OLSH）表现更好。 从图1中可以看到，LEMON实现了持续的性能提高，证明了LEMON可以通过新旧数据库之间的相关性，将更多的语义信息嵌入二进制码。 随着轮次的增加，大多数离线方法的性能都在下降。最有可能的原因是它们在每轮中用所有累积的样本重新训练哈希函数和哈希代码。 大多数方法随着哈希码长度的增加而表现得更好，表明更长的比特可以携带更多的鉴别信息。 大多数方法在文本→图像的任务中比图像→文本的任务中表现得更好，可能的原因是，文本特征可以更好地描述。 其他两个数据集的结果与其类似。 4.2.2 时间成本分析 根据之前的分析知，LEMON的复杂性与新数据的大小呈线性关系。由图四可知，LEMON在所有情况下都是最快的。离线方法需要更长的训练时间，并且时间成本随着回合数的增加而显著增加，因为它们必须对所有累积的数据重新训练哈希函数，这使得它们在在线情况下效率很低；而在线方法的训练时间不会。因此LEMON的训练非常有效，并且可以扩展到大规模在线检索。 4.2.3 参数敏感度分析 我们进行了实验来分析包括α和β在内的参数的敏感性。由图5可以看到，这些参数确实对LEMON的性能有一些影响，但并不明显。 ","date":"2022-11-18","objectID":"/lemon/:4:2","tags":["深度学习"],"title":"Label Embedding Online Hashing for Cross-Modal Retrieval","uri":"/lemon/"},{"categories":["Git"],"content":"问题描述 将项目文件push到GitHub上时，发现GitHub上的文件夹图标上有箭头，且无法打开。 ","date":"2022-11-06","objectID":"/git%E6%8A%A5%E9%94%99-github%E6%96%87%E4%BB%B6%E5%A4%B9%E5%87%BA%E7%8E%B0%E7%AE%AD%E5%A4%B4%E4%B8%94%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/:1:0","tags":["Github","Git"],"title":"Git报错-GitHub文件夹出现箭头且无法打开","uri":"/git%E6%8A%A5%E9%94%99-github%E6%96%87%E4%BB%B6%E5%A4%B9%E5%87%BA%E7%8E%B0%E7%AE%AD%E5%A4%B4%E4%B8%94%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"},{"categories":["Git"],"content":"出错原因 当在自己的项目里clone了别人的项目，github就将他视为一个子系统模块，导致在上传代码时该文件夹上传失败，并在github上显示向右的白色箭头。 ","date":"2022-11-06","objectID":"/git%E6%8A%A5%E9%94%99-github%E6%96%87%E4%BB%B6%E5%A4%B9%E5%87%BA%E7%8E%B0%E7%AE%AD%E5%A4%B4%E4%B8%94%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/:2:0","tags":["Github","Git"],"title":"Git报错-GitHub文件夹出现箭头且无法打开","uri":"/git%E6%8A%A5%E9%94%99-github%E6%96%87%E4%BB%B6%E5%A4%B9%E5%87%BA%E7%8E%B0%E7%AE%AD%E5%A4%B4%E4%B8%94%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"},{"categories":["Git"],"content":"解决方案 删除子文件夹里面的.git文件，执行如下命令： git rm --cached [文件夹名] git add [文件夹名] git commit -m \"commit messge\" git push origin main ","date":"2022-11-06","objectID":"/git%E6%8A%A5%E9%94%99-github%E6%96%87%E4%BB%B6%E5%A4%B9%E5%87%BA%E7%8E%B0%E7%AE%AD%E5%A4%B4%E4%B8%94%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/:3:0","tags":["Github","Git"],"title":"Git报错-GitHub文件夹出现箭头且无法打开","uri":"/git%E6%8A%A5%E9%94%99-github%E6%96%87%E4%BB%B6%E5%A4%B9%E5%87%BA%E7%8E%B0%E7%AE%AD%E5%A4%B4%E4%B8%94%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"},{"categories":["Git"],"content":"问题描述 在将本地的远程仓库push到github上时，出现报错： ssh: Could not resolve hostname github.com: Temporary failure in name resolution fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. ","date":"2022-11-06","objectID":"/git%E6%8A%A5%E9%94%99-ssh%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF/:1:0","tags":["SSH","Github","Git","Ping"],"title":"Git报错-ssh相关错误","uri":"/git%E6%8A%A5%E9%94%99-ssh%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF/"},{"categories":["Git"],"content":"情况1 ssh错误 解决方案：重新设置ssh 1 重新在git设置身份的名字和邮箱 进入到需要提交的文件夹底下，执行命令： git config --global user.name \"yourname\" git config --global user.email \"your@email.com\" 注：yourname是你要设置的名字，your@email是你要设置的邮箱。 2 删除known_hosts文件 进入 .ssh 文件夹，手动删除 known_hosts 文件 3 重新设置ssh git输入命令： ssh-keygen -t rsa -C \"your@email.com\" 接着一路回车，系统会自动在 .ssh 文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打开 id_rsa.pub，复制里面的全部内容。 4 在github上新建SSH key 进入GitHub网站的个人设置界面，在 SSH and GPG keys 中新建一个SSH key，将刚刚复制的密钥粘贴进去。 5 验证是否添加成功 在git中输入命令： ssh -T git@github.com 接着跳出一段话，输入命令：yes，提示重新设置成功！ ","date":"2022-11-06","objectID":"/git%E6%8A%A5%E9%94%99-ssh%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF/:2:0","tags":["SSH","Github","Git","Ping"],"title":"Git报错-ssh相关错误","uri":"/git%E6%8A%A5%E9%94%99-ssh%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF/"},{"categories":["Git"],"content":"情况2 DNS错误 排除了ssh的问题后，在cmd中对目标地址进行ping操作： ping github.com 出现如下错误提示： Ping request could not find host github.com. Please check the name and try again. 说明DNS出现网络问题，解决方案如下： 1 首先获取 github.com IP 地址 IP 地址查询： Click 通过上述网站查询得到 github.com IP 地址如下 140.82.113.4 2 修改hosts文件 以管理员身份打开本地 C:\\Windows\\System32\\drivers\\etc 目录下的 hosts 文件，在文件最下方添加： 140.82.113.4 github.com 完成后保存即可。 3 再次ping github.com 此时再次ping github.com即可看到能够成功ping通。 $ ping 140.82.113.4 Pinging 140.82.113.4 with 32 bytes of data: Reply from 140.82.113.4: bytes=32 time=229ms TTL=42 Reply from 140.82.113.4: bytes=32 time=229ms TTL=42 Reply from 140.82.113.4: bytes=32 time=229ms TTL=42 Reply from 140.82.113.4: bytes=32 time=229ms TTL=42 Ping statistics for 140.82.113.4: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss), Approximate round trip times in milli-seconds: Minimum = 229ms, Maximum = 229ms, Average = 229ms 再次进行git push操作，可以顺利执行。 ","date":"2022-11-06","objectID":"/git%E6%8A%A5%E9%94%99-ssh%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF/:3:0","tags":["SSH","Github","Git","Ping"],"title":"Git报错-ssh相关错误","uri":"/git%E6%8A%A5%E9%94%99-ssh%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF/"},{"categories":["Android"],"content":"1 安装软件 打开命令行，进入apk文件所在目录 输入命令：adb install xxx.apk 2 踩雷记录 ","date":"2022-11-06","objectID":"/%E4%BD%BF%E7%94%A8adb%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/:0:0","tags":["adb","Android"],"title":"使用adb命令安装软件","uri":"/%E4%BD%BF%E7%94%A8adb%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"},{"categories":["Android"],"content":"报错1 android adb devices offline 解决办法：重启adb服务 adb kill-server adb start-server ","date":"2022-11-06","objectID":"/%E4%BD%BF%E7%94%A8adb%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/:0:1","tags":["adb","Android"],"title":"使用adb命令安装软件","uri":"/%E4%BD%BF%E7%94%A8adb%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"},{"categories":["Android"],"content":"报错2 Failed to install app-debug.apk: Failure [INSTALL_FAILED_TEST_ONLY: installPackageLI] 解决办法：允许安装test用的apk adb install -t app-debug.apk ","date":"2022-11-06","objectID":"/%E4%BD%BF%E7%94%A8adb%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/:0:2","tags":["adb","Android"],"title":"使用adb命令安装软件","uri":"/%E4%BD%BF%E7%94%A8adb%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"},{"categories":["Mysql"],"content":"1 数据库、表与完整性约束的定义 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"1.1 创建数据库 进入mysql： mysql -h127.0.0.1 -uroot -p 创建数据库： CREATE DATABASE dbname; 指明访问的数据库： use dbname; ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"1.2 创建表及表的主码约束 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"建表语法 CREATE TABLE为保留字，其语义为创建表对象； IF NOT EXISTS为可选短语，其语义为仅当该表不存在时才创建表；如果不带该短语，创建表时，如果同名表已存在，则输出报错信息； tbl_name为表的名字； (列定义|表约束,…)表示表的其它定义都写在一对括号里，括号里为一个或多个“列定义”或“表约束”，如果有多个列的定义或表约束，则它们之间用逗号隔开。 CREATE TABLE [IF NOT EXISTS] tbl_name (列定义|表约束,...) ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:1","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"列定义语法 [NOT NULL |NULL]表示空或非空约束，缺省为NULL，即该列的内容允许为空值，NOT NULL则约束该列的内容必须为非空； DEFAULT关键字为列指定缺省值，可以是常量，也可以是表达式； AUTO_INCREMENT指定该列为自增列(如1，2，3，…)，一般用于自动编号，显然只有数字类型的列才可以定义这一特性； [UNIQUE]指定该列值具有唯一性（但可以有空值-甚至多个空值的存在，如果该列没有定义NOT NULL约束）； PRIMARY KEY指定该列为主码，相当于定义表的实体完整性约束；只有当主码由单属性组成时，才可以这样定义主码（主码由多属性组成时，应当用表约束来定义）； COMMENT用来给列附加一条注释； “REFERENCES”短语为该列定义参照完整性约束，指出该列引用哪个表的哪一列的值，以及违背参照完整性后的具体处理规则（多个规则中选一），具体内容将在随后的练习里再讲解； CHECK(表达式)为列指定“自定义约束”，只有使（表达式）的值为true的数据才允许写入数据库；关键词CONSTRAINT用来为约束命名。 列定义 ::= 列名 数据类型 [NOT NULL | NULL] [DEFAULT {常量 | (表达式)} ] [AUTO_INCREMENT] [UNIQUE [KEY]] [PRIMARY KEY] [COMMENT '列备注'] [REFERENCES tbl_name (col_name) [ON DELETE RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT] [ON UPDATE RESTRICT|CASCADE|SET NULL| NO ACTION|SET DEFAULT]] [[CONSTRAINT [约束名]] CHECK (表达式)] ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:2","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"表约束语法 主码约束以“PK_”打头，后跟表名，一个表只会有一个主码约束； 外码约束以“FK_”打头，后跟表名及列名； CHECK约束以“CK_”打头，后跟表名及列名。 表约束 ::= [CONSTRAINT [约束名]] | PRIMARY KEY (key_part,...) | UNIQUE (key_part,...) | FOREIGN KEY (col_name,...) REFERENCES tbl_name (col_name,...) [ON DELETE RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT] [ON UPDATE RESTRICT|CASCADE|SET NULL| NO ACTION|SET DEFAULT] | CHECK (表达式) 主码约束及唯一性约束中“key_part”的语法规则如下： key_part::= {列名| (表达式)} [ASC | DESC] ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:3","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"定义主码 单属性主码，既可在列定义里用PRIMARY KEY约束指定主码，也可以作为表约束单独定义； 组合属性作主码时，该主码只能定义为表约束。 表创建好之后可以使用如下语句列出所有的表： show tables; 还可以使用如下语句查看表的结构，用来检查所建的表是否正确体现了原意： DESC 表名; ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:4","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"1.3 创建外码约束 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"外码 外码是表中的一个或一组字段（属性），它可以不是本表的主码，但它与某个主码(同一表或其它表的主码)具有对应关系（语义完全相同）。外码可以是一列或多列，一个表可以有一个或多个外码。当我们谈论外码时，一定有个主码与它对应，外码不可能单独存在。主码所在的表为主表，又称父表，外码所在的表为从表，又称子表。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:1","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"外码约束 外码用来在数据之间（即外码与其对应的主码间）建立关联。参照完整性约束用于约束外码列的取值范围：外码列的取值要么为空，要么等于其对应的主码列的某个取值。在语义允许，又不违反其它约束规则的情形下，外码列的取值才可以为空。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:2","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"定义外码约束 可在定义表的同时定义各种完整性约束规则(当然包括外码约束，亦即参照完整性约束）。外码约束既可以定义为列约束，亦可定义为表约束。 列级外码约束的语法格式如下： 列级外码约束 ::= 列名 数据类型 [REFERENCES tbl_name (col_name) [ON DELETE RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT] [ON UPDATE RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT] 表约外码约束的语法格式如下： 表级外码约束 ::= [CONSTRAINT [约束名]] FOREIGN KEY (col_name,...) REFERENCES tbl_name (col_name,...) [ON DELETE RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT] [ON UPDATE RESTRICT|CASCADE|SET NULL| NO ACTION|SET DEFAULT] MySQL表级外码约束的好处是可以给约束命名，且支持多属性组合外码（即外码由多个列组成）。**事实上，外码约束定义在表一级，是不二的选择，因为MySQL对列级外码约束的支持仅停留在语法检查阶段，实际并没有实现(至少8.0.22还没有实现）。**外码约束的名称一般以“FK_”为前缀，这是约定俗成的规则。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:3","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"1.4 check约束 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"用户定义的完整性约束 关系数据库的完整性约束共有三类：实体完整性约束，参照完整性约束以及用户定义的完整性约束。实体完整性约束和参照完整性约束分别用PRIMARY KEY和FOREIGN KEY来实现；CHECK约束是最主要的一类用户定义的完整性约束，用于定义用户对表中的某列的数据约束，或表中一行中几列之间应该满足的完整性约束。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:1","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"CHECK约束的定义方法 如果约束仅涉及单个列，则该约束既可以定义为列约束，也可以定义为表约束，例如：“性别”列的取值仅限从（“男”,“女”)中取值； 如果约束涉及表的多个列，则该约束只能定义为表约束，例如：如果职称为“教授”，则它的薪资应当不低于6000元。这个约束涉及到“职称”和“薪资”两个列的内容，故只能用表约束来实现。 CHECK约束的语法: CHECK约束 ::= [CONSTRAINT [约束名]] CHECK (条件表达式)] 只有当条件表达式的值为true时，数据（插入的新数据，或修改后的数据）才会被接受，否则将被拒绝。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:2","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"1.5 DEFAULT约束 默认值约束(Default约束)用于给表中的字段指定默认值，即往表里插入一条新记录时，如果没有给这个字段赋值，那么DBMS就会自动赋于这个字段默认值。 Default约束只能定义为列一级约束，即在需要指定默认值的列之后用关键字DEFAULT申明默认值，其语法为： col_name data_type [DEFAULT {literal | (expr)} ] 即在列名与列的数据类型之后申明Default约束。当然Default约束只是众多列约束中的一种，该列可能还有NOT NULL, UNIQUE, AUTO_INCREMENT, CHECK，FOREIGN KEY等其它约束。 DEFAULT关键字引出的默认值可以是常量，也可以是一个表达式。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"举例 AUTO_INCREMENT约束仅用于整数列; DEFAULT约束指定默认值为表达式时，表达式要写在一对括弧里; 这里，curdate()是MySQL的系统函数，其功能是取当前日期; 语句中，表名称order前后的符号是必须的，因为order是MySQL的关键字，当表名或列名与关键字冲突时，名称前后必须加`号。 create table `order`( orderNo int auto_increment primary key, orderDate date default (curdate()), customerNo char(10), employeeNo char(10)); ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:1","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"1.6 UNIQUE约束 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"UNIQUE约束 跟主码(Primary Key)约束一样，Unique约束既可以是对单属性的约束，也可以是对属性组约束，具有Unique约束的属性或属性组的取值必须是唯一的，否则就违反了Unique约束。不过，跟主码不同的是，Unique约束并不要求字段必须非空(Not Null)，所以，实际上，它只能约束非空的属性(组）取值是唯一的。同时具有Not Null约束的Unique属性(组)相当于候选码。一个表只能定义一个主码约束，但可以定义多个Unique约束。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:1","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"UNIQUE约束的语法 跟主码约束一样，单字段的Unique约束既可定义为列约束，亦可定义为表约束，组合字段的Unique约束只能定义为表约束。 Unique列约束的语法为： col_name data_type UNIQUE Unique表约束的语法为： [CONSTRAINT [约束名]] UNIQUE(列1, 列2, ...) Constraint短语可以省略。既使写上关键词constraint，也可以省略约束名。约束未命名时，MySQL将按一定规则自动予以命名。 NOT NULL只能作列约束，且不用命名。UNIQUE约束作列约束时不能自主命名，作表约束时可以自主命名。 2 表结构与完整性约束的修改 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:2","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"2.1 修改表名 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"ALTER TABLE语句 Alter Table语句用于修改由Create Table语句创建的表的结构。比如，添加或删除列，添加或删除约束，创建或销毁索引，更改列的数据类型，更改列名甚至表名等。 ALTER TABLE 表名 [修改事项 [, 修改事项] ...] 常用修改事项有： 用ADD关键词添加列和约束(主码、外码、CHECK、UNIQUE等约束)； 用DROP关键词删除列、约束和索引(含Unique)； 用MODIFY关键词修改列的定义(数据类型和约束)； 用RENAME关键词修改列、索引和表的名称； 用CHANGE关键词修改列的名称，同时还可以修改其定义(类型和约束)。 修改事项 ::= ADD [COLUMN] 列名 数据类型 [列约束] [FIRST | AFTER col_name] | ADD {INDEX|KEY} [索引名] [类型] (列1,...) | ADD [CONSTRAINT [约束名]] 主码约束 | ADD [CONSTRAINT [约束名]] UNIQUE约束 | ADD [CONSTRAINT [约束名]] 外码约束 | ADD [CONSTRAINT [约束名]] CHECK约束 | DROP {CHECK|CONSTRAINT} 约束名 | ALTER [COLUMN] 列名 {SET DEFAULT {常量 | (表达式)} | DROP DEFAULT} | CHANGE [COLUMN] 列名 新列名 数据类型 [列约束] [FIRST | AFTER col_name] | DROP [COLUMN] 列名 | DROP {INDEX|KEY} 索引名 | DROP PRIMARY KEY | DROP FOREIGN KEY fk_symbol | MODIFY [COLUMN] 列名 数据类型 [列约束] [FIRST | AFTER col_name] | RENAME COLUMN 列名 TO 新列名 | RENAME {INDEX|KEY} 索引名 TO 新索引名 | RENAME [TO|AS] 新表名 说明： 注意RENAME,MODIFY和CHANGE的区别：仅改列名，用RENAME; 只改数据类型不改名，用MODIFY; 既改名又改数据类型，用CHANGE。 在用MODIFY,CHANGE更改列的数据类型和约束时，修改后的CHECK约束并不会生效(MySQL只作语法检查，并未实现代码–至少MySQL 8.0.22还未实现)。但用ADD新增列的CHECK约束，是有效的。 删除主码约束只能用Drop Primary Key短语,不能使用drop constraint短语，即便在创建主码约束时显式命名了该主码约束。试图使用“drop constraint 主码约束名”短语删除主码，会给出错误提示，显示该约束并不存在。因为MySQL并没有完全实现“constraint 约束名 primary key(…)”短语的功能，仅作了语法检查，然后直接忽略了主码约束的命名。 给已有列增加Default约束，可用 alter 列 set default ... 短语；删除列的default约束，可用 alter 列 drop default 短语。当然，也可以用 Modify 列名 数据类型 ... 短语。如果该短语没有default约束，就相当于删除了原来的default约束，如果该短语带有default约束，就相当于添加了default约束，如果之前已有default约束，则新的Default约束将代替原有的Default约束; 删除unique约束，既可用 drop constraint 约束名 短语，也可以用 drop key 索引名 短语来实现,唯一性(unique)约束实际是用Unique索引来实现的，Unique索引的名字总是与Unique约束名完全一样，它们本就是同一套机制。如果没有显式命名的话，Unqiue索引名或者说Unique约束名一般与列同名(组合属性作索引，则与组合属性中的第1列同名)。但要注意是的，在更改列名后，Unique索引名并不会随之更改。在创建Unqiue约束时，用“constriant”短语给约束取一个有意义的名字，是一个值得推荐的习惯。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:1","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"更改表名 alter table 表名 rename [TO|AS] 新表名 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:2","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"2.2 添加与删除字段 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"给表添加字段 关键字FIRST指示新添加的列为第1列； AFTER指示新添加的列紧跟在指定列的后面。 如果省略位置指示，则新添加的列将成为表的最后一列。 关键字column可以省略。 ALTER TABLE 表名 ADD [COLUMN] 列名 数据类型 [列约束] [FIRST | AFTER 列名] 举个例子： alter table student add mobile char(11) constraint CK_student_mobile check(mobile rlike '1[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]'); check约束中的rlike还可以用regexp替代，它们是同义语。跟Oracle一样，MySQL用正则匹配表达式来测试字段值是否符合某个pattern，rlike比like关键词所支持的功能要强大得多。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:1","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"删除表中的字段 关键字COLUMN可以省略，其语法格式为： ALTER TABLE 表名 DROP [COLUMN] 列名 举个例子： 在学生档案里记录年龄的作法并不科学，因为年龄会随着时间的变化而变化，档案里记录17岁，还得根据当年记录的日期以及当下的日期推算实际年龄。替代方案是记录出生日期而不是年龄。解决方案： # 第1步：添加列DOB alter table student add DOB date after sex; # 第2步，根据age推算DOB update student set DOB = date_add('2020-9-1', interval -1*age year); # date_add()是mysql的函数 select * from student; # 查看表student的内容 # 第3步，删除列age alter table student drop age; ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:2","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"2.3 修改字段 修改列名、列数据类型和列约束，以及列序的修改事项有： 修改事项 ::= ALTER [COLUMN] 列名 {SET DEFAULT {常量 | (表达式)} | DROP DEFAULT} | CHANGE [COLUMN] 列名 新列名 数据类型 [列约束] [FIRST | AFTER col_name] | MODIFY [COLUMN] 列名 数据类型 [列约束] [FIRST | AFTER col_name] | RENAME COLUMN 列名 TO 新列名 CHANGE短语可修改列名、数据类型和列约束； MODIFY短语可修改列的数据类型和约束； RENAME短语仅用于更改列名； ALTER短语仅用于修改列的DEFAULT约束或删除列的DEFAULT约束。 CHANGE和MODIFY短语还可以修改列在表中的位置。 create database MyDb; use MyDb; create table s( sno char(10) primary key, name varchar(32) not null, ID char(18) unique ); ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"修改字段名称 注意：关键字COLUMN不能省略 ALTER TABLE 表名 RENAME COLUMN 列名 TO 新列名 如果修改列名的同时，还要修改列的类型和约束，则用CHANGE短语： ALTER TABLE 表名 CHANGE [COLUMN] 列名 新列名 数据类型 [列约束] [FIRST | AFTER col_name] 如果新列带有CHECK约束的话，MySQL只会对这个约束作语法检查，并不会去实现这个约束，其它类型的约束没有问题。如果真有这样的需求，不如先DROP之前的列，再ADD新的列，新列附带的CHECK约束是会被实现的。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:1","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"修改字段的数据类型和约束 如果列名称不变，仅需要修改其数据类型和约束，则用MODIFY短语： ALTER TABLE 表名 MODIFY [COLUMN] 列名 数据类型 [列约束] [FIRST | AFTER col_name] 注意，一旦使用MODIFY短语修改列，则该列之前的数据类型、约束将被新的数据类型和约束取而代之。如果之前定义了列约束，修改后不带列约束，相当于删除了之前的约束。 如果需要修改(或添加)列的DEFAULT约束，则既可用上面的MODIFY短语，也可以使用ALTER短语： ALTER TABLE 表名 ALTER [COLUMN] 列名 SET DEFAULT {常量 | (表达式)} 删除列的DEFAULT约束，则可以使用ALTER短语(或MODIFY短语)： ALTER TABLE 表名 ALTER [COLUMN] 列名 DROP DEFAULT ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:2","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"修改字段在表中的位置 如果仅需修改列在表中的位置，仍用MODIFY短语： ALTER TABLE 表名 MODIFY [COLUMN] 列名 数据类型 [列约束] [FIRST | AFTER col_name] 举个例子： alter table resident modify idNo char(18), modify height int unsigned, rename column educationalBackground to education; ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:3","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"2.4 添加、删除与修改约束 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"主码的添加与删除 删除主码： ALTER TABLE 表名 DROP PRIMARY KEY; drop index `PRIMARY` on 表名; 添加主码： ALTER TABLE 表名 ADD [CONSTRAINT [约束名]] PRIMARY KEY(列1,列2,...); MySQL尽管在语法上支持主码约束的命名，但实际上并没有真正实现主码约束的命名功能。即，MySQL并不会创建用户语句中所指定的约束名。所以，试图通过约束名删除主码约束是行不通的。 MySQL中，所有的主码约束(主码索引)名均为PRIMARY，无论怎么命名或更命，这个名字都不会改变。由于PRIMARY是MySQL的保留字，所以，在引用这个主码约束(索引)名时，必须用一对``符号将PRIMARY括起来。 举个例子： # 第1步：删除错误的主码定义 alter table score drop primary key; # 第2步：重新创建主码 alter table score add constraint PK_score primary key(sno,cno); alter table score add primary key(sno,cno); # 进阶版 alter table score drop primary key, add primary key(sno,cno); ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:1","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"外码的删除与添加 删除外码： ALTER TABLE 表名 DROP CONSTRAINT 约束名 ALTER TABLE 表名 DROP FOREIGN KEY 约束名 添加外码： ALTER TABLE 表名 ADD [CONSTRAINT [约束名]] 外码约束 约束名是可选的，如果省略命名短语，MySQL将按一定的规则自动命名。将来如果要删除该约束，必须先查询到该约束的名字（注：从MySQL的数据字典查询）。 创建外码时，MySQL将同步创建外码索引，如果外码约束有显式命名，则外码索引与外码约束同名。如果外码约束未命名，则外码索引与外码列的列名同名。 删除外码约束时，外码索引不会跟着删除。如果将来重新创建了外码，并显式命名，则外码索引会自动更名(与外码约束名保持相同)。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:2","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"CHECK约束的删除与添加 删除check约束： ALTER TABLE 表名 DROP CONSTRAINT 约束名 添加check约束： ALTER TABLE 表名 ADD [CONSTRAINT [约束名]] check(条件表达式) 添加约束时，如果现有数据与该约束规则相矛盾，则创建约束的请求会被拒绝。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:3","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"UNIQUE约束的添加与删除 删除Unique约束： alter table 表名 drop constraint 约束名; drop index 索引名 on 表名; 添加Unique约束： alter table 表名 ADD [CONSTRAINT [约束名]] UNIQUE(列1,...) 创建unique约束时，将同步创建unique索引，索引名与约束同名。如果未显式命名unique约束或索引，MySQL将按一定规则自动命名（单列的unique索引或约束与列同名）。 约束的修改一般通过先删除旧约束再重建新约束来实现。 3存储过程与事务 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:4","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"3.1 使用流程控制语句的存储过程 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:0","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"变量的定义与赋值 用declare语句定义变量，并赋予默认值或初始值，未赋默认值则初始值为null： DECLARE var_name [, var_name] ... type [DEFAULT value] 用set语句给变量赋值，set语句还可以设置许多MySQL的配置参数。 SET variable = expr [, variable = expr] 通过select语句给变量赋值，select语句可以带复杂的where，group by，having等短语。 select col into var_name from table; #将table表中的col列值赋给变量 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:1","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"复合语句与流程控制语句 复合语句BEGIN…END BEGIN [statement_list] END; if语句 IF search_condition THEN statement_list [ELSEIF search_condition THEN statement_list] ... [ELSE statement_list] END IF; while语句 WHILE search_condition DO statement_list END WHILE; ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:2","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"存储过程的定义 存储过程是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。 存储过程是为了完成特定功能的 SQL 语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数（需要时）来调用执行。 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用，即具有名字的一段代码，用来完成一个特定的功能。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:3","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"存储过程的创建和查询 创建存储过程： create procedure 存储过程名(参数) 每个存储的程序都包含一个由 SQL 语句组成的主体。此语句可能是由以分号（;）字符分隔的多个语句组成的复合语句。例如： CREATE PROCEDURE proc1() BEGIN SELECT * FROM user; END; MySQL 本身将分号识别为语句分隔符，因此必须临时重新定义分隔符以使 MySQL 将整个存储的程序定义传递给服务器。 要重新定义 MySQL 分隔符，请使用 delimiter命令。使用 delimiter 首先将结束符定义为//，完成创建存储过程后，使用//表示结束，然后将分隔符重新设置为分号（;）： DELIMITER // CREATE PROCEDURE proc1() BEGIN SELECT * FROM user; END // DELIMITER ; /也可以换成其他符号，例如$; 执行存储过程： call 存储过程名 存储过程的参数： IN：输入参数，也是默认模式，表示该参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回； OUT：输出参数，该值可在存储过程内部被改变，并可返回； INOUT：输入输出参数，调用时指定，并且可被改变和返回。 ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:4","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Mysql"],"content":"存储过程的查询和删除 查询存储过程： SHOW PROCEDURE STATUS WHERE db='数据库名'; 查看存储过程的详细定义信息： SHOW CREATE PROCEDURE 数据库.存储过程名; 删除存储过程： DROP PROCEDURE [IF EXISTS] 数据库名.存储过程名; ","date":"2022-10-28","objectID":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:5","tags":["Mysql"],"title":"Mysql数据库基本语法","uri":"/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Git"],"content":"基本流程 # 初始化仓库 git init # 将本地库关联至远程仓库 git remote add origin git@github.com:....github.io.git # 查看当前修改状态 git status # 添加修改过得文件， . 表示所有，也可以指定文件 git add . # \"\"里面的内容就是提交内容的说明信息 git commit -m \"first commit\" # 第一次提交方法1 git push -u -f origin main #第一次提交方法2 git pull origin main --allow-unrelated-histories git push -u origin main # 以后提交 git push ","date":"2022-10-21","objectID":"/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/:1:0","tags":["Git","Github","Gitee"],"title":"Git基本用法\u0026报错记录","uri":"/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"},{"categories":["Git"],"content":"其他用法 1 修改分支名 git branch -m oldBranchName newBranchName 2 取消与远程仓库的关联 git remote remove origin 3 实现本地库同时关联GitHub和Gitee # 初始化仓库 git init # 将本地库同时和GitHub、Gitee的远程仓库关联 git remote add github git@github.com:bertilchan/gitTest.git git remote add gitee git@gitee.com:bertil/git-test.git # 查看关联的远程库信息 git remote -v # 添加修改，和原来一样 git add . git commit -m \"first commit\" # 分别提交 git push -u github main git push -u gitee main ","date":"2022-10-21","objectID":"/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/:2:0","tags":["Git","Github","Gitee"],"title":"Git基本用法\u0026报错记录","uri":"/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"},{"categories":["Git"],"content":"报错记录 ","date":"2022-10-21","objectID":"/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/:3:0","tags":["Git","Github","Gitee"],"title":"Git基本用法\u0026报错记录","uri":"/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"},{"categories":["Git"],"content":"报错1 ssh: Could not resolve hostname github.com: Temporary failure in name resolution fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 解决方案见：Git报错-ssh相关错误 ","date":"2022-10-21","objectID":"/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/:3:1","tags":["Git","Github","Gitee"],"title":"Git基本用法\u0026报错记录","uri":"/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"},{"categories":["Git"],"content":"报错2 push后GitHub文件夹出现箭头且无法打开 解决方案见：Git报错-GitHub文件夹出现箭头且无法打开 ","date":"2022-10-21","objectID":"/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/:3:2","tags":["Git","Github","Gitee"],"title":"Git基本用法\u0026报错记录","uri":"/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"},{"categories":["Go"],"content":"1 路由与控制器 ","date":"2022-10-20","objectID":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:1:0","tags":["Echo","Go"],"title":"Echo框架入门","uri":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["Go"],"content":"1 路由规则 一条路由规则由：http请求方法 , url路径 , 控制器函数 组成 1.http请求方法 GET POST PUT DELETE 2.url路径 静态url路径 带路径参数的url路径 带星号（*）模糊匹配参数的url路径 // 例子1， 静态Url路径, 即不带任何参数的url路径 /users/center /user/101 /food/100 // 例子2，带路径参数的url路径，url路径上面带有参数,参数由冒号（:）跟着一个字符串定义。 // 路径参数值可以是数值，也可以是字符串 //定义参数:id， 可以匹配/user/1, /user/899 /user/xiaoli 这类Url路径 /user/:id //定义参数:id， 可以匹配/food/2, /food/100 /food/apple 这类Url路径 /food/:id //定义参数:type和:page， 可以匹配/foods/2/1, /food/100/25 /food/apple/30 这类Url路径 /foods/:type/:page // 例子3. 带星号（*）模糊匹配参数的url路径 // 星号代表匹配任意路径的意思 //匹配：/foods/1， /foods/200, /foods/1/20, /foods/apple/1 //以/foods/ 开头的所有路径都匹配 /foods/* 3.url路径匹配顺序 如果出现，一个http请求路径匹配多个定义的url路径，echo框架按下面顺序匹配，先匹配到那个就用那个定义。 匹配静态url路径 匹配带路径参数的url路径 匹配带星号（*）模糊匹配参数的url路径 4.控制器函数 控制器函数接受一个上下文参数，并返回一个错误。可以通过上下文参数，获取http请求参数，响应http请求。 func HandlerFunc(c echo.Context) error{} ","date":"2022-10-20","objectID":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:1:1","tags":["Echo","Go"],"title":"Echo框架入门","uri":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["Go"],"content":"2 示例 实际项目开发中不要把路由定义和控制器函数都写在一个go文件，不方便维护。 //实例化echo对象。 e := echo.New() //定义post请求, url路径为：/users, 绑定saveUser控制器函数 e.POST(\"/users\", saveUser) //定义get请求，url路径为：/users/:id （:id是参数，例如: /users/10, 会匹配这个url模式），绑定getUser控制器函数 e.GET(\"/users/:id\", getUser) //定义put请求 e.PUT(\"/users/:id\", updateUser) //定义delete请求 e.DELETE(\"/users/:id\", deleteUser) //控制器函数实现 func saveUser(c echo.Context) error { ...忽略实现... } func getUser(c echo.Context) error { ...忽略实现... } func updateUser(c echo.Context) error { ...忽略实现... } func deleteUser(c echo.Context) error { ...忽略实现... } ","date":"2022-10-20","objectID":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:1:2","tags":["Echo","Go"],"title":"Echo框架入门","uri":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["Go"],"content":"2 处理请求参数 ","date":"2022-10-20","objectID":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:2:0","tags":["Echo","Go"],"title":"Echo框架入门","uri":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["Go"],"content":"1 绑定数据 通过将请求参数绑定到一个struct对象的方式获取数据。这种方式获取请求参数支持json、xml、k/v键值对等多种方式。 // User 结构体定义 type User struct { Name string `json:\"name\" form:\"name\" query:\"name\"` Email string `json:\"email\" form:\"email\" query:\"email\"` } 控制器代码： // Handler func(c echo.Context) (err error) { u := new(User) //调用echo.Context的Bind函数将请求参数和User对象进行绑定。 if err = c.Bind(u); err != nil { return } //请求参数绑定成功后 u 对象就保存了请求参数。 //这里直接将请求参数以json格式显示 //注意：User结构体,字段标签定义中，json定义的字段名，就是User对象转换成json格式对应的字段名。 return c.JSON(http.StatusOK, u) } ","date":"2022-10-20","objectID":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:2:1","tags":["Echo","Go"],"title":"Echo框架入门","uri":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["Go"],"content":"2 获取post请求数据 通过echo.Context对象的 FormValue 函数可以直接获取post请求参数。 通过FormValue函数获取参数的值，数据类型都是String类型， 如果需要其他类型的数据，需要自己转换数据格式。 // Handler func(c echo.Context) error { //获取name参数 name := c.FormValue(\"name\") //直接输出name参数 return c.String(http.StatusOK, name) } ","date":"2022-10-20","objectID":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:2:2","tags":["Echo","Go"],"title":"Echo框架入门","uri":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["Go"],"content":"3 获取get请求数据 通过echo.Context对象的 QueryParam 函数可以直接获取get请求参数。 // Handler func(c echo.Context) error { //获取name参数, 通过QueryParam获取的参数值也是String类型。 name := c.QueryParam(\"name\") //直接输出name参数 return c.String(http.StatusOK, name) }) ","date":"2022-10-20","objectID":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:2:3","tags":["Echo","Go"],"title":"Echo框架入门","uri":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["Go"],"content":"4 获取path路径参数 通过echo.Context对象的 Param 获取，url路径参数。 //例子: url路由规则为/users/:name , :name为参数。 e.GET(\"/users/:name\", func(c echo.Context) error { //获取路径参数:name的值 name := c.Param(\"name\") //如果请求url为: /users/tizi365 则name的值为tizi365 //Param获取的值也是String类型 return c.String(http.StatusOK, name) }) ","date":"2022-10-20","objectID":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:2:4","tags":["Echo","Go"],"title":"Echo框架入门","uri":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["Go"],"content":"3 处理请求结果 1 以字符串方式响应 String(code int, s string) error 2 以json格式响应 JSON(code int, i interface{}) error 3 以xml格式响应 XML(code int, i interface{}) error 4 以文件格式响应 5 设置http响应头 func(c echo.Context) error { //设置http响应 header c.Response().Header().Add(\"tizi\", \"tizi365\") return c.String(200, \"欢迎访问tizi360.com!\") } ","date":"2022-10-20","objectID":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:3:0","tags":["Echo","Go"],"title":"Echo框架入门","uri":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["Go"],"content":"4 访问静态资源文件 echo通过static中间件支持静态资源文件的访问。我们可以通过echo.Static函数初始化static中间件。 Static(prefix, root string) *Route //初始化echo实例 e := echo.New() //设置Static中间件 //如果我们访问 /res/tizi.jpg这个url路径，实际上就是访问static/tizi.jpg这个路径的内容 e.Static(\"/res\", \"static\") 我们也可以通过Echo.File函数为一个url地址绑定一个静态资源文件。 //初始化echo实例 e := echo.New() //访问 / 就是访问public/index.html文件， index.html相当于站点默认首页 e.File(\"/\", \"public/index.html\") //访问/favicon.ico 就是访问images/favicon.ico文件， 相当于为站点设置了图标 e.File(\"/favicon.ico\", \"images/favicon.ico\") ","date":"2022-10-20","objectID":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:4:0","tags":["Echo","Go"],"title":"Echo框架入门","uri":"/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["Go"],"content":"在go语言标准库中，net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket。 ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:0:0","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"1 服务端 ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:1:0","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"1. 解析地址 在TCP服务端我们需要监听一个TCP地址，因此建立服务端前我们需要生成一个正确的TCP地址，这就需要用到 Resolve 函数。 // ResolveTCPAddr函数会输出一个TCP连接地址和一个错误信息 func ResolveTCPAddr(network, address string) (*TCPAddr, error) // 解析IP地址 func ResolveIPAddr(net, addr string) (*IPAddr, error) // 解析UDP地址 func ResolveUDPAddr(net, addr string) (*UDPAddr, error) // 解析Unix地址 func ResolveUnixAddr(net, addr string) (*UnixAddr, error) ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:1:1","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"2. 监听请求 我们可以通过 Listen 方法监听我们解析后的网络地址。 // 监听net类型，地址为laddr的地址 func Listen(net, laddr string) (Listener, error) // 监听TCP地址 func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error) // 监听IP地址 func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error) // 监听UDP地址 func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error) func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error) // 监听Unix地址 func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error) func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error) ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:1:2","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"3. 接受请求 TCPAddr 实现了两个接受请求的 Accept 方法，两者代码实现其实是一样的，唯一的区别是第一种返回了一个对象，第二种返回了一个接口。 func (l *TCPListener) AcceptTCP() (*TCPConn, error) func (l *TCPListener) Accept() (Conn, error) ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:1:3","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"4. 连接配置 // 配置监听器超时时间：超过t之后监听器自动关闭，0表示不设置超时时间 func (l *TCPListener) SetDeadline(t time.Time) error // 关闭监听器 func (l *TCPListener) Close() error ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:1:4","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"5. 编写一个服务器 func main() { // 解析服务端监听地址，本例以tcp为例 addr, err := net.ResolveTCPAddr(\"tcp\", \"127.0.0.1:8000\") if err != nil { log.Panic(err) } // 创建监听器 listen, err := net.ListenTCP(\"tcp\", addr) if err != nil { log.Panic(err) } for { // 监听客户端连接请求 conn, err := listen.AcceptTCP() if err != nil { continue } // 处理客户端请求 这个函数可以自己编写 go HandleConnectionForServer(conn) } } ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:1:5","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"2 客户端 ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:2:0","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"1. 解析地址 在TCP服务端我们需要监听一个TCP地址，因此建立服务端前我们需要生成一个正确的TCP地址，这就需要用到 Resolve 函数了。 // ResolveTCPAddr函数会输出一个TCP连接地址和一个错误信息 func ResolveTCPAddr(network, address string) (*TCPAddr, error) ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:2:1","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"2. 发送连接请求 // DialIP的作用类似于IP网络的拨号 func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error) // Dial 连接到指定网络上的地址，涵盖 func Dial(network, address string) (Conn, error) // 这个方法只是在Dial上面设置了超时时间 func DialTimeout(network, address string, timeout time.Duration) (Conn, error) // DialTCP 专门用来进行TCP通信的 func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error) // DialUDP 专门用来进行UDP通信的 func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error) // DialUnix 专门用来进行 Unix 通信 func DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error) ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:2:2","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"3. 编写一个客户端 func main() { // 解析服务端地址 RemoteAddr, err := net.ResolveTCPAddr(\"tcp\", \"127.0.0.1:8000\") if err != nil { panic(err) } // 解析本地连接地址 LocalAddr, err := net.ResolveTCPAddr(\"tcp\", \"127.0.0.1\") if err != nil { panic(err) } // 连接服务端 conn, err := net.DialTCP(\"tcp\", LocalAddr, RemoteAddr) if err != nil { panic(err) } // 连接管理 HandleConnectionForClient(conn) } ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:2:3","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"3 域名解析 ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:3:0","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"1. DNS正向解析 CNAME 被称为规范名字。这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。 //域名解析到cname func LookupCNAME(name string) (cname string, err error) //域名解析到地址 func LookupHost(host string) (addrs []string, err error) //域名解析到地址[]IP结构体.可以对具体ip进行相关操作(是否回环地址,子网,网络号等) func LookupIP(host string) (addrs []IP, err error) ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:3:1","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"2. DNS反向解析 // 根据ip地址查找主机名地址(必须得是可以解析到的域名)[dig -x ipaddress] func LookupAddr(addr string) (name []string, err error) ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:3:2","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"4 其他常用接口 ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:4:0","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"1. Conn接口 type Conn interface { // Read从连接中读取数据 // Read方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真 Read(b []byte) (n int, err error) // Write从连接中写入数据 // Write方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真 Write(b []byte) (n int, err error) // Close方法关闭该连接 // 并会导致任何阻塞中的Read或Write方法不再阻塞并返回错误 Close() error // 返回本地网络地址 LocalAddr() Addr // 返回远端网络地址 RemoteAddr() Addr // 设定该连接的读写deadline，等价于同时调用SetReadDeadline和SetWriteDeadline // deadline是一个绝对时间，超过该时间后I/O操作就会直接因超时失败返回而不会阻塞 // deadline对之后的所有I/O操作都起效，而不仅仅是下一次的读或写操作 // 参数t为零值表示不设置期限 SetDeadline(t time.Time) error // 设定该连接的读操作deadline，参数t为零值表示不设置期限 SetReadDeadline(t time.Time) error // 设定该连接的写操作deadline，参数t为零值表示不设置期限 // 即使写入超时，返回值n也可能\u003e0，说明成功写入了部分数据 SetWriteDeadline(t time.Time) error } ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:4:1","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"2. PacketConn接口 type PacketConn interface { // ReadFrom方法从连接读取一个数据包，并将有效信息写入b // ReadFrom方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真 // 返回写入的字节数和该数据包的来源地址 ReadFrom(b []byte) (n int, addr Addr, err error) // WriteTo方法将有效数据b写入一个数据包发送给addr // WriteTo方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真 // 在面向数据包的连接中，写入超时非常罕见 WriteTo(b []byte, addr Addr) (n int, err error) // Close方法关闭该连接 // 会导致任何阻塞中的ReadFrom或WriteTo方法不再阻塞并返回错误 Close() error // 返回本地网络地址 LocalAddr() Addr // 设定该连接的读写deadline SetDeadline(t time.Time) error // 设定该连接的读操作deadline，参数t为零值表示不设置期限 // 如果时间到达deadline，读操作就会直接因超时失败返回而不会阻塞 SetReadDeadline(t time.Time) error // 设定该连接的写操作deadline，参数t为零值表示不设置期限 // 如果时间到达deadline，写操作就会直接因超时失败返回而不会阻塞 // 即使写入超时，返回值n也可能\u003e0，说明成功写入了部分数据 SetWriteDeadline(t time.Time) error } ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:4:2","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"3. Error接口 package net type Error interface{ Timeout() bool // 错误是否超时 Temporary() bool // 是否是临时错误 } ","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:4:3","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["Go"],"content":"5 示例 server.go /*服务器代码*/ package main import ( \"fmt\" \"net\" ) func main() { //创建listener listener, err := net.Listen(\"tcp\", \"localhost:50000\") //用来监听和接收来自客户端的请求 if err != nil { fmt.Println(\"Error Listening\", err.Error()) //Error是个什么? return //终止程序 } //无限循环，监听并接受来自客户端的连接 for { conn, err := listener.Accept() if err != nil { fmt.Println(\"Error accepting\", err.Error()) return //终止程序 } go doServerStuff(conn) //? } } func doServerStuff(conn net.Conn) { for { buf := make([]byte, 512) len, err := conn.Read(buf) //获取客户端发送字节数 if err != nil { fmt.Println(\"Error reading\", err.Error()) return //终止程序 } fmt.Printf(\"Received data:%v\\n\", string(buf[:len])) } } client.go package main import ( \"bufio\" \"fmt\" \"net\" \"os\" \"strings\" ) func main() { //创建和服务器的连接 conn, err := net.Dial(\"tcp\", \"localhost:50000\") if err != nil { fmt.Println(\"Error dialing\", err.Error()) //由于目标计算机积极拒绝而无法创建连接 return //终止程序 } inputReader := bufio.NewReader(os.Stdin) //接收来自键盘的输入 fmt.Println(\"First,what is your name?\") clientName, _ := inputReader.ReadString('\\n') trimmedClient := strings.Trim(clientName, \"\\r\\n\") // Windows 平台下用 \"\\r\\n\"，Linux平台下使用 \"\\n\" //给服务器发送信息知道程序退出 for { fmt.Println(\"What to send to the server? Type Q to quit.\") input, _ := inputReader.ReadString('\\n') trimmedInput := strings.Trim(input, \"\\r\\n\") if trimmedInput==\"Q\"{ return } _,err=conn.Write([]byte(trimmedClient+\" says: \"+trimmedInput)) } } socket.go package main import( \"fmt\" \"io\" \"net\" ) func main(){ var( host=\"www.apache.org\" port=\"80\" remote=host+\":\"+port msg string=\"GET / \\n\" data=make([]uint8,4096) read=true count=0 ) //创建一个socket conn,err:=net.Dial(\"tcp\",remote) //发送我们的消息：一个http GET请求 io.WriteString(conn,msg) //读取服务器的响应 for read{ count,err=conn.Read(data) read=(err==nil) fmt.Printf(string(data[0:count])) } conn.Close() } dial.go //make a connection with www.example.org: package main import( \"fmt\" \"net\" \"os\" ) func main(){ conn,err:=net.Dial(\"tcp\",\"192.0.32.10:80\") //tcp ipv4 checkConnection(conn,err) conn,err=net.Dial(\"udp\",\"192.0.32.10:80\") //udp checkConnection(conn,err) conn,err=net.Dial(\"tcp\",\"[2620:0:2d0:200::10]:80\") //tcp ipv6 checkConnection(conn,err) } func checkConnection(conn net.Conn,err error){ if err!=nil{ fmt.Printf(\"error %v connecting!\",err) os.Exit(1) } fmt.Printf(\"Connection is made with %v\\n\",conn) } server_simple.go package main import( \"flag\" \"fmt\" \"net\" \"syscall\" ) const maxread=25 func main(){ flag.Parse() //服务器地址和端口通过命令行传入参数，并通过flag包来读取这些参数 if flag.NArg() != 2 { //检查是否按照期望传入了2个参数 panic(\"usage: host port\") //此函数停止执行，并将控制权返还给其调用者 } hostAndPort := fmt.Sprintf(\"%s:%s\", flag.Arg(0), flag.Arg(1)) //格式化成字符串 listener := initServer(hostAndPort) for { conn, err := listener.Accept() //接受请求，返回conn对象 checkError(err, \"Accept: \") go connectionHandler(conn) } } func initServer(hostAndPort string)net.Listener{ serverAddr,err:=net.ResolveTCPAddr(\"tcp\",hostAndPort) //解析TCP地址 checkError(err,\"Resolving address:port failed: '\"+hostAndPort+\"'\") listener,err:=net.ListenTCP(\"tcp\",serverAddr) //监听请求 checkError(err,\"ListenTCP: \") println(\"Listening to: \",listener.Addr().String()) return listener } func connectionHandler(conn net.Conn){ connFrom:=conn.RemoteAddr().String() //获取客户端的地址 println(\"Connection from: \",connFrom) sayHello(conn) for{ var ibuf []byte=make([]byte, maxread+1) //设置maxread防止溢出 length,err:=conn.Read(ibuf[0:maxread]) //读取连接中的内容 ibuf[maxread]=0 switch err{ case nil: handleMsg(length,err,ibuf) case syscall.EAGAIN: continue //重新尝试连接 default: goto DISCONNECT } } DISCONNECT: err:=conn.Close() //关闭连接 println(\"Closed connection: \",connFrom) checkError(err,\"Close: \") } func sayHello(to net.Conn) { obuf := []byte{'L', 'e', 't', '\\'', 's', ' ', 'G', 'O', '!', '\\n'} wrote, err := to.Write(obuf) //发送message给客户端 checkError(err, \"Write: wrote \"+string(wrote)+\" bytes.\") } func handleMsg(length int, err error, msg []byte) { if length \u003e 0 { print(\"\u003c\", length, \":\") for i := 0; ; i++ { if msg[i] == 0 { break } fmt.Printf(\"%c\", msg[i]) } print(\"\u003e\") } } func checkError(error error, info string) { if error !=","date":"2022-10-20","objectID":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/:5:0","tags":["Go"],"title":"Go-net标准库应用","uri":"/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/"},{"categories":["深度学习"],"content":"本文为论文 Vision GNN: An Image is Worth Graph of Nodes 的阅读笔记。 论文下载：https://arxiv.org/abs/2206.00272 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:0:0","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"引言 网络架构在基于深度学习的计算机视觉中起着关键作用。广泛使用的CNN和 transformer（变换器）将图像视为 grid（网格）或 sequence（序列）结构，这对于捕捉不规则、复杂的物体来说是不灵活的。本文建议将图像表示为一个 graph 结构，并引入一个新的 Vision GNN（ViG）架构来提取视觉任务的图层特征。 文章主要工作： 介绍了计算机视觉方面的现有模型方法和成果 介绍ViG模型的构建过程及工作原理，为未来的研究提供有用的灵感和经验 通过图像分类和物体检测实验证明了ViG模型在视觉任务中的有效性 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:1:0","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"1 相关研究 CNN 曾经是计算机视觉中标准的网络结构，但近来 transformer with attention mechanism 、MLP-based 等模型也在不断发展，这些正在将视觉模型推向一个前所未有的高度。 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:2:0","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"1.1 3种图像结构 不同的网络结构以不同的方式处理输入的图像，通常有grid, sequence ,graph 3种，如下图所示。在 grid 和 sequence 结构中，节点只按空间位置排序；在 graph 结构中，节点是通过其内容连接的，不受局部位置的限制。 CNN 在图像上应用滑动窗口，并引入移位变异性和位置性；最近的 vision transformer 或 MLP 将图像视为 a sequence of patches（补丁序列）。 由于物体形状通常不是规则的四边形，常用的 grid 或 sequence 结构处理起图像来不够灵活，所以在本文中采用 graph 结构。 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:2:1","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"1.2 3种模型 CNN：曾经是计算机视觉中的主流网络结构，已经成功地应用于各种视觉任务，如图像分类、物体检测和语义分割。CNN模型在过去的十年里发展迅速，代表性的模型包括ResNet、MobileNet和NAS。 Vision transformer：从2020年开始，被引入到视觉任务中，ViT的一些变体开始被提出来以提高视觉任务的性能。主要的改进包括金字塔结，局部注意和位置编码。 MLP：通过专门设计的模块，MLP可以达到有竞争力的性能，并且在一般的视觉任务（如物体检测和分割）上工作。 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:2:2","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"1.3 GNN模型 1. GNN\u0026GCN GNN：图神经网络，由于传统的CNN网络无法表示顶点和边这种关系型数据，便出现了图神经网络解决这种图数据的表示问题，这属于CNN往图方向的应用扩展 GCN：图卷积神经网络，GNN在训练过程中，有将attention引入图结构的，有将门控机制引入图结构的，还有将卷积引入图结构的，引入卷积的GNN就是GCN，通过提取空间特征来进行学习 2. 发展 Micheli提出了早期的提出了早期的基于空间的GCN，Bruna等人提出了基于频谱的GCN，近几年来基于这两种GCN的改进和扩展也被提出。 3. 应用 GCN通常被应用于图数据，如社会网络、引文网络和生化图；在计算机视觉领域的应用主要包括点云分类、场景图生成和动作识别。 GCN只能解决自然形成的图的特定视觉任务，对于计算机视觉的一般应用，我们需要一个基于GCN的骨干网络来直接处理图像数据。 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:2:3","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"2 ViG模型 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:3:0","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"2.1 模型构建 Image→Graph 首先基于 graph 结构建立视觉图形神经网络，用于视觉任务。将输入的图像划分为若干个 patches（补丁），并将每个斑块视为一个 node （节点）。1 . 对于一个大小为 $H×W×3$ 的图像，我们将其分为 N 个补丁，把每个补丁转化为一个特征向量 $x_i∈R^D$，得到 $X = [x_1,x_2,…,x_N ]$， 其中 $D$ 是特征维度。将特征看做无序节点$V={v_1,v_2,…,v_N}$，节点$v_i$的k邻近节点记为$N(v_i)$，对每个$v_j∈N(v_i)$添加$v_j$到$v_i$的边$e_ji$。 最终得到图$G = (V,E) $，我们把图的构建过程记为$G = G(X)$。 图层处理 图卷积层可以通过聚合其邻居节点的特征在节点之间交换信息。具体操作方式为： $G' = F(G, W)=Update(Aggregate(G, W_agg), W_update) $ 其中，$W_agg$和 $W_update$是聚合、更新操作的可学习权重。 聚合：通过聚合邻居节点的特征来计算一个节点的表征 更新：进一步合并聚合的特征 通过最大相对卷积处理图层面，记为$X' = GraphConv(X)$。 $x_i' = h(x_i, g(x_i, N(x_i), W_agg), W_update)$ $g(·) = x_i'' = [x_i, max(${$x_j - x_i|j∈N(x_i)$}] $h(·) = x_i' = x_i'‘W_update$ . 接着进行图卷积的多头更新操作（有利于特征多样性），将聚合后的特征 $x_i’'$ 分割成 $h$ 个头，然后分别以不同的权重更新这些头，得到： $x_i' = [head^1W^1update, head^2W^2update,…head^hW^hupdate]$ ViG block ViG的2个基本模块 Graph模块：是在图卷积的基础上构建的，用于聚合和更新图形信息，可以缓解传统GNN的过度平滑现象 FFN模块：带有两个线性层，用于节点特征转换和鼓励节点多样性 以前的GCN通常重复使用卷积层来提取图形数据的聚合特征，这会导致过度平滑的现象 ，降低节点特征的显著性，如下图所示所示。为了解决这个问题，本文在ViG块中引入了更多的特征转换和非线性激活。 我们在图卷积前后应用一个线性层，将节点特征投射到同一领域，增加特征多样性。在图卷积之后插入一个非线性激活函数以避免层崩溃。我们称升级后的模块为Grapher模块，给定输入特征$X∈R^N×^D$ ，则可得到：$Y = σ(GraphConv(XW_in))W_out + X$ 2 . 其中$W_in$和$W_out$是全连接层的权重，σ是激活函数。为了进一步提高特征转换能力，我们在每个节点上利用前馈网络（FFN）：$Z = σ(YW_1)W_2 + Y$ 其中$W_1$和$W_2$是全连接层的权重。Graph模块和FFN模块的堆叠构成了ViG块，作为构建网络的基本单元。基于图像的graph结构和ViG块，我们可以建立ViG网络。 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:3:1","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"2.2 网络框架 各项同性结构：指主体在整个网络中具有同等大小和形状的特征 金字塔结构：考虑了图像的多尺度特性，提取特征的空间大小逐渐变小 在计算机视觉领域，常用的结构有各向同性结构和金字塔结构。为了与其他类型的神经网络有更普遍的比较，文章分别为ViG建立了这两种网络结构。 各向同性结构 文章建立了3个大小不同的各向同性ViG架构。为了扩大感受野，邻居结点的数量K从9线性增加到18；头的数量被设定为 h = 4。详情如下表：3 金字塔结构 文章建立了4个大小不同的金字塔ViG模型。详情如下：4 位置编码 为了表示节点的位置信息，文章为每个节点特征添加一个位置向量：$x_i←x_i+e_i$ ；金字塔结构中可以进一步使用相对位置编码。 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:3:2","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"2.3 模型优点 graph 是广义的数据结构，grid 和 sequence 可以看做 graph 的特例 graph 更灵活，可以对复杂、不规则的物体进行建模 一个物体可以被看作是由各个部分组成的，graph 结构可以构建他们的联系 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:3:3","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"3 实验 top1 accuracy：预测的label取最后概率向量里面最大的那一个作为预测结果，如果预测结果中概率最大的分类正确，则预测正确，否则预测错误。 top5 accuracy：最后概率向量最大的前五名中，只要出现了正确概率即为预测正确，否则预测错误。 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:4:0","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"3.1 实验结果 本文分别将各向同性结构、金字塔结构的ViG与同样结构的CNN、转化器和 MLPs对比，可以看出： 将图片视作Graph能够在计算机视觉任务中取得非常好的结果 和各向同性结构相比，金字塔结构的ViG具有更好的性能 各向同性结构的实验结果： 金字塔结构的实验结果： ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:4:1","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"3.2 消融研究 消融研究：通过删除部分网络并研究网络的性能来更好的了解网络。 文章以各向同性的ViG-Ti为基础架构，在ImageNet分类任务上进行了消融研究，结果如下： 通过改变图卷积的类型，发现不同图卷积的Top-1准确率很高，说明ViG架构的灵活性。其中，最大相对卷积在计算量和精度之间实现了最佳的权衡。 直接利用图卷积进行图像分类的效果很差，可以通过添加更多的特征转换，如引入FC和FFN不断提高准确性。 太少的邻居结点会降低信息交流，太多会导致过度平滑。当邻居节点的数量在9-15的范围时表现较好。 头的数量 h=4时，计算量和精度可以最好平衡。 ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:4:2","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["深度学习"],"content":"3.3 可视化 为了更好地理解本文的ViG模型是如何工作的，作者可视化了构建的图结构，展示了两个不同深度的样本的图。五角星是中心节点，相同颜色的节点是其邻居。 可以看到，在浅层，邻居节点往往是根据低层次、局部特征来选择的，如颜色和纹理；在深层层中，中心节点的邻居更具语义性，属于同一类别。而本文的ViG网络可以通过其内容和语义表征逐渐将节点联系起来，并帮助更好地识别物体。 参考资料： 从图(Graph)到图卷积(Graph Convolution)：漫谈图神经网络模型 (一) 图卷积神经网络(GCN) GRAPH CONVOLUTIONAL NETWORKS 不用像素当做节点的原因：会导致节点过多 ↩︎ 最后加上 $X$​ 是残差连接，为了避免过拟合。 ↩︎ FLOPs：浮点运算数，可以用来衡量算法/模型的复杂度。 ↩︎ E是FNN中的隐藏维度 ↩︎ ","date":"2022-10-17","objectID":"/an-image-is-worth-graph-of-nodes/:4:3","tags":["深度学习","GNN"],"title":"Vision GNN: An Image is Worth Graph of Nodes","uri":"/an-image-is-worth-graph-of-nodes/"},{"categories":["Go"],"content":"1 结构 go run helloworld.go：执行Go代码 go build helloworld.go：编译生成二进制文件 ./helloworld：运行 import 声明必须跟在文件的 package 声明之后 Go 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句 函数的左括号 { 必须和 func 函数声明在同一行上，且位于末尾，不能独占一行 在表达式 x+y 中，可在 + 后换行，不能在 + 前换行 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"2 基础语法 //格式化字符串 var stockcode = 123 var enddate = \"2020-12-31\" var url = \"Code=%d\u0026endDate=%s\" var target_url = fmt.Sprintf(url, stockcode, enddate) fmt.Println(target_url) ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"3 语言类型 布尔型 数字型 整形：int uint 浮点型：float complex 字符串 派生类型 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"4 变量 变量声明 var identifier type（指定变量类型，如果没有初始化，则变量默认为零值 var v_name = value（根据值自行判断变量类型 v_name := value（只能在函数体中出现 // 这种因式分解关键字的写法一般用于声明全局变量 var ( vname1 v_type1 vname2 v_type2 ) 局部变量不允许声明但不使用，全局变量可以 a, b = b, a （简单交换2个变量 _：空白标识符，也用于被抛弃值 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"5 常量 const identifier [type] = value //用作枚举 const ( Unknown = 0 Female = 1 Male = 2 ) 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值（必须是内置函数 iota 在const关键字出现时将被重置为0，const中每新增一行常量声明将使 iota 计数一次 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"6 条件语句 switch 匹配项后面也不需要再加 break fallthrough 执行后面的case case后面是类型不被局限于常量或整数，可以加多个，必须类型相同 func main() { var grade string = \"B\" var marks int = 90 switch marks { case 90: grade = \"A\" case 80,70: grade = \"B\" default: grade = \"D\" } switch { case grade == \"A\": fmt.Println(\"youxiu\") case grade == \"B\", grade == \"C\": fmt.Println(\"lianghao\") default: fmt.Println(\"cha\") } } type switch 判断某个 interface 变量中实际存储的变量类型 select 通信的 switch 语句 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"7 循环语句 for循环 for init; condition; post { } for condition { } for { } //range格式可以对 slice、map、数组、字符串等进行迭代循环 for key, value := range oldMap { newMap[key] = value } for key := range oldMap for _, value := range oldMap 在多重循环中，可以用标号 label 标出想 break 的循环 在多重循环中，可以用标号 label 标出想 continue 的循环 goto 语句可以无条件地转移到过程中指定的行 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"8 函数 func function_name( [parameter list] ) [return_types] { 函数体 } 函数可作为实参 匿名函数，可作为闭包 //方法 func (variable_name variable_data_type) function_name() [return_type]{ /* 函数体*/ } ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"9 变量作用域 局部变量：作用域只在函数体内 全局变量：整个包甚至外部包（被导出后）使用 全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"10 数组 var variable_name [SIZE] variable_type 可以使用 ... 代替数组的长度 // 将索引为 1 和 3 的元素初始化 balance := [...]float32{1:2.0,3:7.0} 多维数组 使用 append() 函数向空的二维数组添加两行一维数组 //多维数组 var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type 可以创建各个维度元素数量不一致的多维数组 //向函数传递数组 void myFunction(param [10]int) { ... } ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"11 指针 var var_name *var-type 指针数组 var ptr [MAX]*int; 指向指针的指针 var ptr **int; ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"12 结构体 //定义结构体 type struct_variable_type struct { member definition ... member definition } //声明变量 variable_name := structure_variable_type {value1, value2...valuen} variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen} 访问结构体：结构体.成员名 结构体作为函数参数 结构体指针 //声明 var struct_pointer *Books 结构体指针用 . 访问结构体成员 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:12:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"13 切片(Slice) var identifier []type //定义切片 var slice1 []type = make([]type, len) //创建切片 make([]T, length, capacity) //capacity指定容量，为可选参数 s :=[] int {1,2,3 } //直接初始化切片 s := arr[:] //初始化切片 s，是数组 arr 的引用 s := arr[startIndex:endIndex] //将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片 len() 方法获取长度 cap() 可以测量切片最长可以达到多少 空切片(nil)：切片未初始化，默认为nil，长度为0 copy() 方法拷贝切片 append() 方法向切片追加新元素 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:13:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"14 范围(range) 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素 在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对 //读取key,value for key, value := range oldMap { newMap[key] = value } //只读取key for key := range oldMap //只读取value for _, value := range oldMap range也可以用来枚举 Unicode 字符串 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:14:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"15 集合(Map) 无序的键值对的集合 /* 声明变量，默认 map 是 nil */ var map_variable map[key_data_type]value_data_type /* 使用 make 函数 */ map_variable := make(map[key_data_type]value_data_type) delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:15:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"16 接口 /* 定义接口 */ type interface_name interface { method_name1 [return_type] method_name2 [return_type] ... method_namen [return_type] } /* 定义结构体 */ type struct_name struct { /* variables */ } /* 实现接口方法 */ func (struct_name_variable struct_name) method_name1() [return_type] { /* 方法实现 */ } ... func (struct_name_variable struct_name) method_namen() [return_type] { /* 方法实现*/ } ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:16:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"17 错误处理 type error interface { Error() string } func Sqrt(f float64) (float64, error) { if f \u003c 0 { return 0, errors.New(\"math: square root of negative number\") } // 实现 } ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:17:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Go"],"content":"18 并发 //goroutine语法 go 函数名( 参数列表 ) 同一个程序中的所有 goroutine 共享同一个地址空间 通道（channel） 是用来传递数据的一个数据结构 通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯 操作符 \u003c- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道 //声明通道 ch := make(chan int) //设置发送缓冲区 ch := make(chan int, 100) //遍历通道 v, ok := \u003c-ch //关闭通道 cl 参考资料： Go语言教程 ","date":"2022-10-16","objectID":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:18:0","tags":["Go"],"title":"Go基本语法","uri":"/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"}]