<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>菜菜的秘密花园</title>
        <link>https://imcaicai.github.io/</link>
        <description>菜菜的秘密花园</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 06 Jan 2023 10:32:14 &#43;0800</lastBuildDate>
            <atom:link href="https://imcaicai.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>数组链表-滑动窗口算法</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</link>
    <pubDate>Fri, 06 Jan 2023 10:32:14 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</guid>
    <description><![CDATA[本文主要记录最难掌握的一类双指针技巧——滑动窗口算法。算法思路很简单，就是维护一个窗口，不断滑动，时间复杂度为 O(N)。大致逻辑如下：
1 2 3 4 5 6 7 8 9 10 11  int left = 0, right = 0; while (right &lt; s.size()) { // 增⼤窗⼝ 	window.add(s[right]); right++; while (window needs shrink) { // 缩⼩窗⼝ 	window.remove(s[left]); left++; } }   滑动窗口算法的代码框架如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /* 滑动窗⼝算法框架 */ void slidingWindow(string s) { unordered_map&lt;char, int&gt; window; int left = 0, right = 0; while (right &lt; s.]]></description>
</item>
<item>
    <title>数组链表-双指针技巧解决数组题</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E8%A7%A3%E5%86%B3%E6%95%B0%E7%BB%84%E9%A2%98/</link>
    <pubDate>Thu, 05 Jan 2023 17:58:47 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E8%A7%A3%E5%86%B3%E6%95%B0%E7%BB%84%E9%A2%98/</guid>
    <description><![CDATA[在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：左右指针和快慢指针。所谓左右指针，就是两个指针相向而行或者相背而行；而所谓快慢指针，就是两个指针同向而行。
1 快慢指针技巧 题目 力扣 26. 删除有序数组中的重复项
给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
将最终结果插入 nums 的前 k 个位置后返回 k 。
不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
解析 我们让慢指针 slow 走在后面，快指针 fast 走在前面探路，找到⼀个不重复的元素就赋值给 slow 并让 slow 前进⼀步。 这样，就保证了 nums[0..slow] 都是无重复的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组去重之后的结果。 代码实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public int removeDuplicates(int[] nums) { if(nums.]]></description>
</item>
<item>
    <title>数组链表-双指针技巧解决链表题</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E9%A2%98/</link>
    <pubDate>Sat, 31 Dec 2022 00:08:35 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E9%A2%98/</guid>
    <description><![CDATA[1 合并两个有序链表 题目 力扣 21. 合并两个有序链表
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例：
1 2  输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]   解析 这题比较简单，直接用 while 循环每次比较 p1 和 p2 的大小，把较小的节点接到结果链表上，如图所示：
 虚拟头节点技巧  通过虚拟头节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。 当你需要创造⼀条新链表的时候，可以使⽤虚拟头结点简化边界情况的处理。   最后通过 p.next = n1; 将剩余的节点全都复制过去，不需要使用 while 循环一条一条复制。  代码实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { // 虚拟头结点  ListNode p = new ListNode(), res = p; ListNode n1 = list1, n2 = list2; while(n1!]]></description>
</item>
<item>
    <title>数组链表-差分数组</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</link>
    <pubDate>Fri, 30 Dec 2022 16:40:47 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</guid>
    <description><![CDATA[差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。
1 原理 题目 给出⼀个数组 nums，要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减3，再给 nums[0..4] 全部加 2&hellip;&hellip;N步操作后问，最后 nums 数组的值是什么？
解析 常规思路：
用for循环都给 nums[i&hellip;j] 加上 val ，时间复杂度为 O(N)。由于对 nums 频繁修改，效率很低。
差分数组：
对 nums 数组构造⼀个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差。原理如图：
这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可。
只要花费 O(1) 的时间修改 diff 数组，就相当于给 nums 的整个区间做了修改。多次修改 diff，然后通过 diff 数组反推，即可得到 nums 修改后的结果。
代码实现如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // 差分数组⼯具类 class Difference { // 差分数组 	private int[] diff; /* 输⼊⼀个初始数组，区间操作将在这个数组上进⾏ */ public Difference(int[] nums) { assert nums.]]></description>
</item>
<item>
    <title>数组链表-前缀和</title>
    <link>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%89%8D%E7%BC%80%E5%92%8C/</link>
    <pubDate>Thu, 29 Dec 2022 16:40:47 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8-%E5%89%8D%E7%BC%80%E5%92%8C/</guid>
    <description><![CDATA[前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。
1 一维数组中的前缀和 题目 力扣 303. 区域和检索 - 数组不可变
给定一个整数数组 nums，计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;= right，实现 NumArray 类：
 NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )  示例：
1 2 3 4 5 6 7 8 9 10 11  输入： [&#34;NumArray&#34;, &#34;sumRange&#34;, &#34;sumRange&#34;, &#34;sumRange&#34;] [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] 输出： [null, 1, -1, -3] 解释： NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.]]></description>
</item>
<item>
    <title>C&#43;&#43;面向对象(一)</title>
    <link>https://imcaicai.github.io/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%80/</link>
    <pubDate>Thu, 29 Dec 2022 10:50:18 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%80/</guid>
    <description><![CDATA[1 类&amp;对象 1.1 成员函数 成员函数可以定义在类定义内部：
1 2 3 4 5 6 7 8 9 10 11 12  class Box { public: double length; // 长度  double breadth; // 宽度  double height; // 高度  double getVolume(void) { return length * breadth * height; } };   也可以在类的外部使用范围解析运算符 :: 定义该函数。
1 2 3 4 5 6 7 8 9 10 11 12 13  class Box { public: double length; // 长度  double breadth; // 宽度  double height; // 高度  double getVolume(void);// 返回体积 }; double Box::getVolume(void) { return length * breadth * height; }   在 :: 运算符之前必须使用类名。]]></description>
</item>
<item>
    <title>C&#43;&#43;基础语法(三)</title>
    <link>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%89/</link>
    <pubDate>Tue, 27 Dec 2022 20:28:05 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%89/</guid>
    <description><![CDATA[11 字符串 C风格字符串 字符串实际上是使用 null 字符 \0 终止的一维字符数组。
1 2  char site[7] = {&#39;R&#39;, &#39;U&#39;, &#39;N&#39;, &#39;O&#39;, &#39;O&#39;, &#39;B&#39;, &#39;\0&#39;}; char site[] = &#34;RUNOOB&#34;;   字符串相关函数：
 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号。 strlen(s1); 返回字符串 s1 的长度。 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。  String类 1 2 3 4 5 6 7 8 9  string str1 = &#34;runoob&#34;; string str2 = &#34;google&#34;; string str3; int len ; // 连接 str1 和 str2 str3 = str1 + str2; // 连接后，str3 的总长度为12！ len = str3.]]></description>
</item>
<item>
    <title>C&#43;&#43;基础语法(二)</title>
    <link>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BA%8C/</link>
    <pubDate>Tue, 27 Dec 2022 20:23:48 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BA%8C/</guid>
    <description><![CDATA[6 运算符 sizeof运算符 sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。
逗号运算符 整个逗号表达式的值为系列中最后一个表达式的值。从本质上讲，逗号的作用是将一系列运算按顺序执行。
逗号之前的自增表达式也会在逗号结束后执行！
1 2 3 4 5 6  // 运行完结果：count=19，incr=10，var=20 var = (count=19, incr=10, count+1); // 结果：j=11，i=1010 j = 10; i = (j++, j+100, 999+j);   成员运算符 .（点）运算符和 -&gt;（箭头）运算符用于引用类、结构和共用体的成员。访问结构的成员时使用点运算符，而通过指针访问结构的成员时，则使用箭头运算符。例如，假设有下面的结构：
1 2 3 4  struct Employee { char first_name[16]; int age; } emp;   点运算符：
1  strcpy(emp.first_name, &#34;zara&#34;);   箭头运算符：
1 2  // p_emp 是一个指针，指向类型为 Employee 的对象 strcpy(p_emp-&gt;first_name, &#34;zara&#34;);   强制转换运算符 1 2  double a = 21.]]></description>
</item>
<item>
    <title>C&#43;&#43;基础语法(一)</title>
    <link>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%80/</link>
    <pubDate>Tue, 27 Dec 2022 14:48:21 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%80/</guid>
    <description><![CDATA[1 C++简介 C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：封装、抽象、继承、多态
标准的 C++ 由三个重要部分组成：
 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。  2 数据类型 基本内置类型 bool，char，int，float，double，void
类型修饰符 signed，unsigned，short，long
C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 long。
typedef 声明 可以使用 typedef 为一个已有的类型取一个新的名字。
1  typedef int feet;   枚举类型 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓&quot;枚举&quot;是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。
1 2 3 4  enum 枚举名{ 标识符[=整型常数], ... } 枚举变量;   默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。
1 2 3 4 5  enum color { red, green, blue } c; c = blue; // red默认为0，blue默认为6 enum color { red, green=5, blue };   变量声明 当使用多个文件且只在其中一个文件中定义变量时，可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。]]></description>
</item>
<item>
    <title>算法和刷题的框架思维</title>
    <link>https://imcaicai.github.io/%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%B7%E9%A2%98%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4/</link>
    <pubDate>Fri, 23 Dec 2022 22:20:00 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%B7%E9%A2%98%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4/</guid>
    <description><![CDATA[1 数据结构的存储方式 1.1 数据结构&amp;存储方式 数据的存储方式只有两种：数组（顺序存储）和链表（链式存储）。
【队列】【栈】
【图】：链表实现就是邻接表，二维数组实现就是邻接矩阵
【散列表】
【树】：数组实现就是堆（完全二叉树），链表实现就是普通二叉树
1.2 数组&amp;链表优缺点 数组：
 紧凑连续存储,可以随机访问，通过索引快速找到对应元素，节约存储空间。 内存空间必须⼀次性分配够，扩容时需要重新分配空间，再把数据全部复制过去，时间复杂度 O(N) 插⼊和删除时间复杂度 O(N)  链表：
 元素不连续，不存在数组的扩容问题； 如果知道某⼀元素的前驱和后驱，插入删除时间复杂度 O(1) 存储空间不连续，不能随机访问 每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。  2 数据结构的基本操作 数据结构的基本操作：遍历+访问（增删查改），分为线性/非线性。
线性即for/while迭代，非线性即递归。
🟡 【数组遍历框架】 迭代
1 2 3 4 5  void traverse(int[] arr) { for (int i = 0; i &lt; arr.length; i++) { // 迭代访问 arr[i] 	} }   🟢 【链表遍历框架】 迭代/递归
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* 基本的单链表节点 */ class ListNode { int val; ListNode next; } void traverse(ListNode head) { for (ListNode p = head; p !]]></description>
</item>
</channel>
</rss>
