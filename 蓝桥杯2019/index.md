# 【蓝桥杯】2019题解


⏰总用时：170			🎯总分：39

| 题号   | 时间 | 结果 | 满分 | 难度 | 备注                                |
| ------ | ---- | ---- | ---- | ---- | ----------------------------------- |
| **1**  | 5    | ✅    | 5    | 🌕    |                                     |
| **2**  | 5    | ✅    | 5    | 🌕    |                                     |
| **3**  | 5    | ✅    | 10   | 🌕    |                                     |
| **4**  | 20   | ❌    | 10   | 🌓    | 🔹 巧妙构造数组可以简化题目<br/>     |
| **5**  | 35   | ❌    | 10   | 🌓    | 🔸 【分数取模】、【快速幂】<br/>     |
| **6**  | 20   | 20%  | 15   | 🌓    | 🔹 观察题目的判断结论<br/>🔹 二分查找 |
| **7**  | 40   | 40%  | 20   | 🌓    |                                     |
| **8**  | 30   | 40%  | 20   | 🌓    |                                     |
| **9**  | 10   | ❌    | 25   | 🌑    |                                     |
| **10** |      |      | 25   |      |                                     |

## 1 【填空】求和

### 题目

小明对数位中含有 2、0、1、9 的数字很感兴趣，在 11 到 4040 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。

请问，在 1 到 2019 中，所有这样的数的和是多少？

### 解析

注意审题，求的是满足条件的数字平方之和，不是个数❗❗❗

```c++
#include <bits/stdc++.h>
using namespace std; 

bool check(int x){
	int t;
	while(x){
		t=x%10;
		if(t==2 || t==0 || t==1 || t==9)
			return true;
		x=x/10;
	}
	return false;
}

int main(){
	long long sum=0;
	for(int i=1;i<=2019;i++){
		if(check(i))	sum+=(i*i);
	}
	cout<<sum;
	return 0;
} 
```

## 2 【填空】数列求值

### 题目

给定数列 1,1,1,3,5,9,17,⋯，从第 4 项开始，每项都是前 3 项的和。

求第 20190324 项的最后 4 位数字。

### 解析

```c++
#include <bits/stdc++.h>
using namespace std; 

int main(){
	int a=1,b=1,c=1,t;
	for(int i=1;i<=20190324;i++){
		if(i<=3)	continue;
		t=c;
		c=(a+b+c)%10000;	// 第 i 项 
		a=b;b=t;
//		cout<<i<<": "<<a<<" "<<b<<" "<<c<<endl;
	}
	
	cout<< c; 
	return 0;
} 
```

## 3 最大降雨量

### 题目

由于沙之国长年干旱，法师小明准备施展自己的一个神秘法术来求雨。

这个法术需要用到他手中的 49 张法术符，上面分别写着 1 至 49 这 49 个数字。法术一共持续 7 周，每天小明都要使用一张法术符，法术符不能重复使用。

每周，小明施展法术产生的能量为这周 7 张法术符上数字的中位数。法术 施展完 7 周后，求雨将获得成功，降雨量为 7 周能量的中位数。

由于干旱太久，小明希望这次求雨的降雨量尽可能大，请大最大值是多少？

### 解析

```c++
cout<<34;
```

## 4 迷宫

### 题目

下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。

```
010000
000100
001001
110000
```

迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。

对于上面的迷宫，从入口开始，可以按 `DRRURRDDDR` 的顺序通过迷宫， 一共 10 步。其中 D*、*U*、*L*、*R 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。

请注意在字典序中 D*<*L*<*R*<*U。

```
01010101001011001001010110010110100100001000101010
00001000100000101010010000100000001001100110100101
01111011010010001000001101001011100011000000010000
01000000001010100011010000101000001010101011001011
00011111000000101000010010100010100000101100000000
11001000110101000010101100011010011010101011110111
00011011010101001001001010000001000101001110000000
10100000101000100110101010111110011000010000111010
00111000001010100001100010000001000101001100001001
11000110100001110010001001010101010101010001101000
00010000100100000101001010101110100010101010000101
11100100101001001000010000010101010100100100010100
00000010000000101011001111010001100000101010100011
10101010011100001000011000010110011110110100001000
10101010100001101010100101000010100000111011101001
10000000101100010000101100101101001011100000000100
10101001000000010100100001000100000100011110101001
00101001010101101001010100011010101101110000110101
11001010000100001100000010100101000001000111000010
00001000110000110101101000000100101001001000011101
10100101000101000000001110110010110101101010100001
00101000010000110101010000100010001001000100010101
10100001000110010001000010101001010101011111010010
00000100101000000110010100101001000001000000000010
11010000001001110111001001000011101001011011101000
00000110100010001000100000001000011101000000110011
10101000101000100010001111100010101001010000001000
10000010100101001010110000000100101010001011101000
00111100001000010000000110111000000001000000001011
10000001100111010111010001000110111010101101111000
```

### 解析

🟠 **构造数组 dp[i] = j** ：满足 a[k]^a[j]=x，且 1≤ k ≤ i 的 j 的最大值。由于我们是按索引由小到大遍历的，因此必有 **dp[i] ≤ i** 。

🟡 构造数组的值和它的索引的映射： **map<long long,int> mp**

🟢 注意事实：**若 a ^ b=x，则 a ^ x=b，且 b ^ x=a。** 因此和 t 异或的值为 x 的数是 t^x，它的索引是 mp[t^x]。

🔵 根据以上两点，我们可以这样更新 dp[i]： **dp[i]=max(dp[i-1], mp[t^x]);**

🟣 要使索引 [l, r] 上的值能两两异或得到 x ，只要保证在 r 之前有一个数，和它异或为 x 的数的索引大于 l，即 **dp[r]>=l** 。 **注意由 dp[i] ≤ i 可知，这个数范围一定在 [l, r] 内。**

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

int main(){
	int n,m,l,r;
	int dp[100005]={0};		// dp[i]=j：a[i]^a[j]=x，且 j<=i 
	long long x,t;
	map<long long,int> mp;	// 数列的数和对应的索引 
	cin>>n>>m>>x;
	
	for(int i=1;i<=n;i++){
		scanf("%lld", &t);
		
		dp[i]=max(dp[i-1], mp[t^x]);
		mp[t]=i; 
	}
	
	for(int i=0;i<m;i++){
		scanf("%d %d",&l,&r);
		if(dp[r]>=l)	cout<<"yes"<<endl;
		else cout<<"no"<<endl;
	}
	
	return 0;
	
}
```

## 5 爬树的甲壳虫

### 题目

有一只甲壳虫想要爬上一颗高度为 n 的树，它一开始位于树根，高度为 0，

当它尝试从高度 i-1 爬到高度为 i 的位置时有 $P_i$ 的概率会掉回树根，求它从树根爬到树顶时，经过的时间的期望值是多少。

**输入格式**

输入第一行包含一个整数 n 表示树的高度。

接下来 n 行每行包含两个整数 $x_i, y_i$ ，用一个空格分隔，表示 $P_i=x_i/y_i$ 。

**输出格式**

输出一行包含一个整数表示答案, 答案是一个有理数, 请输出答案对质 数 998244353 取模的结果。

其中有理数 a/b 对质数 P 取模的结果是整数 c 满足 0≤c<P 且 c ⋅ b ≡ a(modP) 。

### 解析

🟠 **【分数取模问题】** 

由费马小定理得：$a^{p-1}=1(mod p)$，其中 p 为质数， a 不为 p 的倍数。

可以推出：$a^{p-2}(mod p)=(a^{p-1}(mod p)*a^{-1}(mod p))(mod p)=a^{-1}(mod p)$。

因此 $a/b(mod p)=(ab^{-1})(mod p)=(a(mod p)*b^{p-2}(mod p))(mod p)$。

🟡 **利用快速幂计算 $b^{p-2}(mod p)$。**

🟢 **【找递推关系】**

设 E[i] 为从点 i 到达点 n 的期望时间，则 **所求答案为 `E[0]`，且 E[n]=0。**

有递推关系： `E[i] = p[i]×(E[0]+1) + (1−p[i])×(E[i+1]+1)` 。**注意，从 i 无论走到 0 还是走到 i+1，所花费的时间都是1。** 很容易可以看出， **E[i] 是一个和 E[0] 有关的一次式** ，设 `E[i] = a[i]E[0] + b[i]` 。

由递推关系得： `a[i-1]=p[i-1]+(1-p[i-1])×a[i]` ， `b[i-1]=(1-p[i-1])×b[i]+1` 。

🔵 注意要把 x 和 y 化成最简分数，可用 c++ 自带函数 `__gcd(x, y)`

```c++
#include <bits/stdc++.h>
using namespace std;
#define P 998244353				// 注意宏定义不能和下面的变量重名！！！ 

// 求 a^b(mod p) 
int qm(long long a, long long b, long long p){
	long long c=1;
	while(b){
		if(b&1)
			c=c*a%p;
		a=a*a%p;
		b>>=1;		// 这里忘记加 "="，陷入死循环了！！！ 
	}
	return c;
}

int main()
{
	int n;
    long long x[100005],y[100005];
    cin>>n;
    for(int i=0;i<n;i++){
    	scanf("%d %d",&x[i],&y[i]);
    	int d=__gcd(x[i],y[i]);		// 求最大公约数
		x[i]/=d,y[i]/=d;				// 化简成最简分数 
	}
    
    long long p0,p1,a=0,b=0;
    for(int i=n-1;i>=0;i--){
    	p0=x[i]*qm(y[i],P-2,P)%P;
    	p1=(y[i]-x[i])*qm(y[i],P-2,P)%P;
    	a=(p0+p1*a%P)%P;
    	b=(p1*b%P+1)%P;
	}
	
	long long ans=(-b*qm(a-1,P-2,P)%P+P)%P;
	cout<< ans;
    
    return 0;
}
```

## 6 青蛙过河

### 题目

小青蛙住在一条河边, 它想到河对岸的学校去学习。小青蛙打算经过河里 的石头跳到对岸。

河里的石头排成了一条直线, 小青蛙每次跳跃必须落在一块石头或者岸上。 不过, 每块石头有一个高度, 每次小青蛙从一块石头起跳, 这块石头的高度就 会下降 1 , 当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃 后使石头高度下降到 0 是允许的)。

小青蛙一共需要去学校上 x 天课, 所以它需要往返 2x 次。当小青蛙具有 一个跳跃能力 y 时, 它能跳不超过 y 的距离。

请问小青蛙的跳跃能力至少是多少才能用这些石头上完 x 次课。

**输入格式**

输入的第一行包含两个整数 n,x, 分别表示河的宽度和小青蛙需要去学校 的天数。请注意 2x 才是实际过河的次数。

第二行包含 n-1 个非负整数 $H_1, H_2,...,H_{n-1}$ , 其中 $H_i>0$ 表示在河中与 小青蛙的家相距 i 的地方有一块高度为 $H_i$ 的石头, $H_i=0$ 表示这个位置没有石头。

**输出格式**

输出一行, 包含一个整数, 表示小青蛙需要的最低跳跃能力。

### 解析

🟠 **当跳跃能力为 y 时，对每个长度为 y-1 的区间 [l, r]，2x 次全程都会经过这个区间 2x 次，因此这个区间的总高度至少为 2x 。** 据此我们写出判断函数 check()。

🟡 用**【二分查找】** ，找出最小的 y。注意判断后的转移式 ❗❗❗

```c++
#include <bits/stdc++.h>
using namespace std;

int n,x;
int h[100005],s[100005];

// 检查长度为 y-1的闭区间内，总高度是不是都超过 2x
// 若超过则说明跳跃能力可以为 y 
bool check(int y){
	for(int i=1;i<=n-y;i++){
		if(s[i+y-1]-s[i-1]<2*x)	return false;
	}
	return true;
}

 int main(){
 	cin>>n>>x;
 	h[0]=s[0]=0;
 	for(int i=1;i<n;i++){
 		scanf("%d",&h[i]);
 		s[i]=s[i-1]+h[i];
	}
	
	int l=1,r=n;
	while(l!=r){			// 二分法找到最小能符合要求的值 
        // 注意如果符合条件，应该继续找小的！！！
		if(check((l+r)/2))	r=(l+r)/2;
		else	l=(l+r)/2+1;
	}
	
	cout<<r;
	return 0;
 }
```

## 7 最长不下降子序列

### 题目

给定一个长度为 N 的整数序列: $A_1, A_2,...,A_N$ 。现在你有一次机会, 将其 中连续的 K 个数修改成任意一个相同值。请你计算如何修改可以使修改后的数 列的最长不下降子序列最长, 请输出这个最长的长度。

最长不下降子序列是指序列中的一个子序列, 子序列中的每个数不小于在 它之前的数。

### 输入格式

输入第一行包含两个整数 N 和 K 。

第二行包含 N 个整数 $A_1, A_2,...,A_N$ 。

### 输出格式

输出一行包含一个整数表示答案。

### 解析



## 8 扫描游戏



## 9 数的拆分



## 10 推导部分和

