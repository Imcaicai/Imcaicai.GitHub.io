<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - 菜菜的秘密花园</title>
        <link>https://imcaicai.github.io/posts/</link>
        <description>All Posts | 菜菜的秘密花园</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 27 Dec 2022 20:28:05 &#43;0800</lastBuildDate><atom:link href="https://imcaicai.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>C&#43;&#43;基础语法(三)</title>
    <link>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%89/</link>
    <pubDate>Tue, 27 Dec 2022 20:28:05 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%89/</guid>
    <description><![CDATA[11 字符串 C风格字符串 字符串实际上是使用 null 字符 \0 终止的一维字符数组。
1 2  char site[7] = {&#39;R&#39;, &#39;U&#39;, &#39;N&#39;, &#39;O&#39;, &#39;O&#39;, &#39;B&#39;, &#39;\0&#39;}; char site[] = &#34;RUNOOB&#34;;   字符串相关函数：
 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号。 strlen(s1); 返回字符串 s1 的长度。 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。  String类 1 2 3 4 5 6 7 8 9  string str1 = &#34;runoob&#34;; string str2 = &#34;google&#34;; string str3; int len ; // 连接 str1 和 str2 str3 = str1 + str2; // 连接后，str3 的总长度为12！ len = str3.]]></description>
</item>
<item>
    <title>C&#43;&#43;基础语法(二)</title>
    <link>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BA%8C/</link>
    <pubDate>Tue, 27 Dec 2022 20:23:48 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BA%8C/</guid>
    <description><![CDATA[6 运算符 sizeof运算符 sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。
逗号运算符 整个逗号表达式的值为系列中最后一个表达式的值。从本质上讲，逗号的作用是将一系列运算按顺序执行。
逗号之前的自增表达式也会在逗号结束后执行！
1 2 3 4 5 6  // 运行完结果：count=19，incr=10，var=20 var = (count=19, incr=10, count+1); // 结果：j=11，i=1010 j = 10; i = (j++, j+100, 999+j);   成员运算符 .（点）运算符和 -&gt;（箭头）运算符用于引用类、结构和共用体的成员。访问结构的成员时使用点运算符，而通过指针访问结构的成员时，则使用箭头运算符。例如，假设有下面的结构：
1 2 3 4  struct Employee { char first_name[16]; int age; } emp;   点运算符：
1  strcpy(emp.first_name, &#34;zara&#34;);   箭头运算符：
1 2  // p_emp 是一个指针，指向类型为 Employee 的对象 strcpy(p_emp-&gt;first_name, &#34;zara&#34;);   强制转换运算符 1 2  double a = 21.]]></description>
</item>
<item>
    <title>C&#43;&#43;基础语法(一)</title>
    <link>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%80/</link>
    <pubDate>Tue, 27 Dec 2022 14:48:21 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/c-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%80/</guid>
    <description><![CDATA[1 C++简介 C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：封装、抽象、继承、多态
标准的 C++ 由三个重要部分组成：
 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。  2 数据类型 基本内置类型 bool，char，int，float，double，void
类型修饰符 signed，unsigned，short，long
C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 long。
typedef 声明 可以使用 typedef 为一个已有的类型取一个新的名字。
1  typedef int feet;   枚举类型 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓&quot;枚举&quot;是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。
1 2 3 4  enum 枚举名{ 标识符[=整型常数], ... } 枚举变量;   默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。
1 2 3 4 5  enum color { red, green, blue } c; c = blue; // red默认为0，blue默认为6 enum color { red, green=5, blue };   变量声明 当使用多个文件且只在其中一个文件中定义变量时，可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。]]></description>
</item>
<item>
    <title>算法和刷题的框架思维</title>
    <link>https://imcaicai.github.io/%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%B7%E9%A2%98%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4/</link>
    <pubDate>Fri, 23 Dec 2022 22:20:00 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%B7%E9%A2%98%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4/</guid>
    <description><![CDATA[1 数据结构的存储方式 1.1 数据结构&amp;存储方式 数据的存储方式只有两种：数组（顺序存储）和链表（链式存储）。
【队列】【栈】
【图】：链表实现就是邻接表，二维数组实现就是邻接矩阵
【散列表】
【树】：数组实现就是堆（完全二叉树），链表实现就是普通二叉树
1.2 数组&amp;链表优缺点 数组：
 紧凑连续存储,可以随机访问，通过索引快速找到对应元素，节约存储空间。 内存空间必须⼀次性分配够，扩容时需要重新分配空间，再把数据全部复制过去，时间复杂度 O(N) 插⼊和删除时间复杂度 O(N)  链表：
 元素不连续，不存在数组的扩容问题； 如果知道某⼀元素的前驱和后驱，插入删除时间复杂度 O(1) 存储空间不连续，不能随机访问 每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。  2 数据结构的基本操作 数据结构的基本操作：遍历+访问（增删查改），分为线性/非线性。
线性即for/while迭代，非线性即递归。
🟡 【数组遍历框架】 迭代
1 2 3 4 5  void traverse(int[] arr) { for (int i = 0; i &lt; arr.length; i++) { // 迭代访问 arr[i] 	} }   🟢 【链表遍历框架】 迭代/递归
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* 基本的单链表节点 */ class ListNode { int val; ListNode next; } void traverse(ListNode head) { for (ListNode p = head; p !]]></description>
</item>
<item>
    <title>Mysql数据库基本语法(四)</title>
    <link>https://imcaicai.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%9B%9B/</link>
    <pubDate>Wed, 07 Dec 2022 14:51:25 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%9B%9B/</guid>
    <description><![CDATA[7 并发控制与事务的隔离级别 7.1 并发控制与事务的隔离级别 并发操作可能产生的数据不一致性 数据库是共享资源，允许多个用户同时访问同一数据库，特别是在互联网应用成为主流的当下，高可用性、高并发是所有应用追求的目标。但并发操作不加控制，便会产生数据的不一致性。 并发操作可能带来的数据不一致性包括：
 丢失修改(lost update) 读脏数据(dirty read) 不可重复读(non-repeatable read) 幻读(phantom read)  为解决上述不一致性问题,DBMS设计了专门的并发控制子系统，采用封锁机制进行并发控制，以保证事务的隔离性和一致性(事务是并发控制的基本单位)。
但事务的隔离程度越高，固然一致性&ndash;或者説数据的正确性越有保障，但并发度就会越低。很多时候，需要在一致性和并发度间进行取舍，从而就生产了事务的隔离级别的概念。 隔离级别越高，一致性程度越高，并发度越低。反之，隔离级别越低，并发度越高，但代价是会出现某些数据不一致现象。
低隔离级别可以支持更高的并发处理，同时占用的系统资源更少,但可能产生数据不一致的情形也更多一些。
查询事务的隔离级别 可用以下语句查询MySQL的事务隔离级别：
1  select @@GLOBAL.transaction_isolation, @@transaction_isolation;   其中，@@GLOBAL.transaction_isolation全局变量，@@transaction_isolation为本会话期内的变量。通常通过重设该变量的值以改变隔离级别。 上述两个变量的缺省值均为：REPEATABLE-READ，即可重复读。
设置事务的隔离级别 以下语句设置事务的隔离级别为可读未提交(read uncommitted):
1  set session transaction isolation level read uncommitted;   如需设置为其它级别，只需替换最后的隔离级别即可。 不同的事务隔离级别意味着不同的封锁协议，程序员只需设置事务的隔离级别即可，其它的交给DBMS并发子系统处理。 不过，MySQL也有lock tables和unlock tables语句，可以直接锁表，另外，MySQL还支持在select语句中使用for share或for update短语主动申请S锁或X锁(只到事务结束才释放)。这样，即使在隔离级别为read uncommitted的情形下，仍有机会保证可重复读，相关内容请参阅MySQL官方文档。
7.2 读脏 读脏 读脏(dirty read)，或者又叫脏读，是指一个事务(t1)读取到另一个事务(t2)修改后的数据，后来事务t2又撤销了本次修改(即事务t2以roll back结束)，数据恢复原值。这样，事务t1读到的数据就与数据库里的实际数据不一致，这样的数据被称为“脏”数据，意即不正确的数据。
读脏产生的原因 显然，产生读脏的原因，是事务t1读取数据时，修改该数据的事务t2还没有结束(commit或roll back，统称uncommitted),且t1读取的时间点又恰在t2修改该数据之后。
7.3 不可重复读 不可重复读 不可重复读(unrepeatable read)，是指一个事务(t1)读取到某数据后，另一个事务(t2)修改了该，事务t1并未修改该数据，但当t1再次读取该数据时，发现两次读取的结果不一样。
产生不可重复读的原因 显然，不可重复读产生的原因，是事务t1的两次读取之间，有另一个事务修改了t1读取的数据。]]></description>
</item>
<item>
    <title>Mysql数据库基本语法(三)</title>
    <link>https://imcaicai.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%89/</link>
    <pubDate>Wed, 07 Dec 2022 14:46:05 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%89/</guid>
    <description><![CDATA[5 用户自定义函数 函数其实有多种，比如标量函数(仅返回一个值)和表函数(返回结果是表),语法也各不相同。这里，我们仅给出一个简化的创建标量函数的语法:
1 2 3 4 5 6  create function function_name([para data_type[,...]]) returns data_type begin function_body; return expression; end    function_name:函数名； para:参数名； data_type:参数的数据类型； 一个函数可以没有参数，也可以有多个。多参数间用逗号分隔。 function_body:函数体。即由合法的SQL语句组成的程序段。 expression:函数返回值，可以是常量、表达式，甚至是一条select语句查询的值（必须保证结果唯一);该值类型应与returns短语定义的类型相同。  函数一旦定义，就可以像内部函数一样使用，比如出现在select列表、表达式、以及where子句的条件中。
 MySQL的函数定义与存储过程的定义一样，在定义函数之前要用“delimiter 界符”语句指定函数定义的结束界符，并在函数定义后，再次使用“delimiter 界符”语句恢复MySQL语句的界符(分号)。
 6 安全性控制 与大多数商用DBMS一样，MySQL采用自主存取控制(DAC)机制进行安全性管理。通过用户，数据对象，权限，授权，收回权限等要素进行存取控制。另外，为了方便批量授权给同一类用户，引入了角色。
6.1 用户（User） MySQL创建用户的语句：
1  create user 用户名 identified by 用户登录密码；   通常用户名可包含域名，限定用户在该域名内登录再有效。例：
1  CREATE USER &#39;jeffrey&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;;   该语句创建用户jeffrey,密码为&rsquo;password'，仅限在MySQL服务器本机上登录才有效。用户名与域合起来，被称为账户(account)。 注意不要写成：&lsquo;jeffrey@localhost&rsquo;，它代表账户： &lsquo;jeffrey@localhost&rsquo;@'%' 意即用户名为jefrrey@localhost，在任何机器上登录都有效。两者的含义完全不同。
drop user语句可删除用户。用户被删除时，该用户拥有的权限自动被收回。]]></description>
</item>
<item>
    <title>Mysql数据库基本语法(二)</title>
    <link>https://imcaicai.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BA%8C/</link>
    <pubDate>Wed, 07 Dec 2022 14:45:58 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BA%8C/</guid>
    <description><![CDATA[3存储过程与事务 3.1 使用流程控制语句的存储过程 变量的定义与赋值 用declare语句定义变量，并赋予默认值或初始值，未赋默认值则初始值为null：
1  DECLARE var_name [, var_name] ... type [DEFAULT value]   用set语句给变量赋值，set语句还可以设置许多MySQL的配置参数。
1  SET variable = expr [, variable = expr]   通过select语句给变量赋值，select语句可以带复杂的where，group by，having等短语。
1  select col into var_name from table; #将table表中的col列值赋给变量   复合语句与流程控制语句 复合语句BEGIN&hellip;END
1 2 3  BEGIN [statement_list] END;   if语句
1 2 3 4  IF search_condition THEN statement_list [ELSEIF search_condition THEN statement_list] ... [ELSE statement_list] END IF;   while语句]]></description>
</item>
<item>
    <title>Mysql数据库基本语法(一)</title>
    <link>https://imcaicai.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%80/</link>
    <pubDate>Wed, 07 Dec 2022 14:45:49 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%80/</guid>
    <description><![CDATA[1 数据库、表与完整性约束的定义 1.1 创建数据库 进入mysql：
1  mysql -h127.0.0.1 -uroot -p   创建数据库：
1  CREATE DATABASE dbname;   指明访问的数据库：
1  use dbname;   1.2 创建表及表的主码约束 建表语法  CREATE TABLE为保留字，其语义为创建表对象； IF NOT EXISTS为可选短语，其语义为仅当该表不存在时才创建表；如果不带该短语，创建表时，如果同名表已存在，则输出报错信息； tbl_name为表的名字； (列定义|表约束,&hellip;)表示表的其它定义都写在一对括号里，括号里为一个或多个“列定义”或“表约束”，如果有多个列的定义或表约束，则它们之间用逗号隔开。  1 2  CREATE TABLE [IF NOT EXISTS] tbl_name (列定义|表约束,...)   列定义语法  [NOT NULL |NULL]表示空或非空约束，缺省为NULL，即该列的内容允许为空值，NOT NULL则约束该列的内容必须为非空； DEFAULT关键字为列指定缺省值，可以是常量，也可以是表达式； AUTO_INCREMENT指定该列为自增列(如1，2，3，&hellip;)，一般用于自动编号，显然只有数字类型的列才可以定义这一特性； [UNIQUE]指定该列值具有唯一性（但可以有空值-甚至多个空值的存在，如果该列没有定义NOT NULL约束）； PRIMARY KEY指定该列为主码，相当于定义表的实体完整性约束；只有当主码由单属性组成时，才可以这样定义主码（主码由多属性组成时，应当用表约束来定义）； COMMENT用来给列附加一条注释； “REFERENCES”短语为该列定义参照完整性约束，指出该列引用哪个表的哪一列的值，以及违背参照完整性后的具体处理规则（多个规则中选一），具体内容将在随后的练习里再讲解； CHECK(表达式)为列指定“自定义约束”，只有使（表达式）的值为true的数据才允许写入数据库；关键词CONSTRAINT用来为约束命名。  1 2 3 4 5 6 7 8 9  列定义 ::= 列名 数据类型 [NOT NULL | NULL] [DEFAULT {常量 | (表达式)} ] [AUTO_INCREMENT] [UNIQUE [KEY]] [PRIMARY KEY] [COMMENT &#39;列备注&#39;] [REFERENCES tbl_name (col_name) [ON DELETE RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT] [ON UPDATE RESTRICT|CASCADE|SET NULL| NO ACTION|SET DEFAULT]] [[CONSTRAINT [约束名]] CHECK (表达式)]   表约束语法  主码约束以“PK_”打头，后跟表名，一个表只会有一个主码约束； 外码约束以“FK_”打头，后跟表名及列名； CHECK约束以“CK_”打头，后跟表名及列名。  1 2 3 4 5 6 7 8  表约束 ::= [CONSTRAINT [约束名]] | PRIMARY KEY (key_part,.]]></description>
</item>
<item>
    <title>计算机网络知识总结</title>
    <link>https://imcaicai.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
    <pubDate>Sat, 03 Dec 2022 11:05:24 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
    <description><![CDATA[最近在复习计算机网络考试，于是按照《计算机网络自顶向下方法》（原书第7版）一书梳理了1-7章的知识，其中第五章的内容合并到第四章中了。
1 计算机网络和因特网 2 应用层 3 运输层 4 网络层 6 链路层和局域网 7 无线网络和局域网 ]]></description>
</item>
<item>
    <title>Label Embedding Online Hashing for Cross-Modal Retrieval</title>
    <link>https://imcaicai.github.io/lemon/</link>
    <pubDate>Fri, 18 Nov 2022 23:33:29 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/lemon/</guid>
    <description><![CDATA[本文为论文 Label Embedding Online Hashing for Cross-Modal 的阅读笔记。
论文下载：https://doi.org/10.1145/3394171.3413971
1 简介 学习散列，作为最著名的近似近邻搜索技术之一，近年来吸引了很多人的注意。它旨在将高维实值特征映射到紧凑的二进制编码，同时保留原始空间中的相似性。然后，可以用XOR操作在Hamming空间中进行搜索，效率高，存储成本低。
许多跨模态散列方法已经被提出并取得了很好的性能。但大多数现有的方法通过批处理学习二进制代码或哈希函数。即在学习过程前，所有的训练数据都可用。这将产生以下问题：
 实际数据通常以流方式收集，有新数据到来时，批处理方法需要对所有数据重新训练 → 效率低 训练集随训练时间变大 → 计算成本高  为了解决这些问题，在线散列被提出，但仍存在问题：
 大多数在线散列方法是为单模态检索设计的，很难直接扩展到跨模态检索。少数在线跨模态散列模型被提出，但性能较差，因为异质模态之间的关联性难以捕捉。 只根据新到达的数据更新散列函数，忽略了新旧数据间的相关性 → 丢失现有数据的信息 → 现有在线散列。 新数据到来时，哈希函数可以有效地重新训练，但哈希码必须对所有累积数据重构 → 更新方案低效。 离散优化大多采用松弛策略 → 量化误差大。  为了解决上述问题，这篇文章提出了一种新的监督下的跨模式检索的在线散列方法，即Label EMbedding ONline hashing，简称LEMON。本文的主要贡献总结如下：
  提出了一种新的有监督的在线散列检索方法，即LEMON。  它通过一个标签嵌入框架来捕捉语义结构，其中包括标签相似性的保存和标签重构，从而得到更有辨识度的二进制码。 通过优化内积最小化问题将新旧数据的哈希码连接起来，解决了更新不平衡问题。 采用两步学习策略，有效地更新哈希函数和二进制码，同时保持旧数据库的哈希代码不可更改，使其计算复杂度仅与流数据的大小有关。   提出了一种迭代优化算法来离散地解决二进制优化问题，极大地减少 量化误差。 在三个基准数据集上的实验结果表明，LEMON在跨模式检索任务上优于一些先进的离线和在线散列方法，并且可以扩展到大规模数据集。   2 相关工作 现有工作存在的问题：
 单模态：不能直接用于跨模态检索任务；必须在每一轮更新所有的二进制代码，效率非常低 多模态：不能跨模态检索 跨模态：不能充分利用原始特征、语义标签；不能很好地以流的方式来捕捉数据的相似性信息   单模态：查询和要检索的文档都只有一个模态（图像→图像）
多模态：查询和要检索的文档必须至少有一个模态相同（图像、文本→图像、文本）
跨模态：查询和要检索的文档模态不同（图像→文本）
 3 方法 3.1 Notations 假设每个样本由 $l$ 个模态组成。在第 $t$ 轮，一个新的数据块 $\vec{X}^{(t)}$ 被添加到数据库中。常用变量的说明如下：]]></description>
</item>
</channel>
</rss>
