<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - 菜菜的秘密花园</title>
        <link>https://imcaicai.github.io/posts/</link>
        <description>All Posts | 菜菜的秘密花园</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 28 Oct 2022 10:15:12 &#43;0800</lastBuildDate><atom:link href="https://imcaicai.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Mysql数据库基本语法</title>
    <link>https://imcaicai.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
    <pubDate>Fri, 28 Oct 2022 10:15:12 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
    <description><![CDATA[1 数据库、表与完整性约束的定义 1.1 创建数据库 进入mysql：
1  mysql -h127.0.0.1 -uroot -p   创建数据库：
1  CREATE DATABASE dbname;   指明访问的数据库：
1  use dbname;   1.2 创建表及表的主码约束 建表语法  CREATE TABLE为保留字，其语义为创建表对象； IF NOT EXISTS为可选短语，其语义为仅当该表不存在时才创建表；如果不带该短语，创建表时，如果同名表已存在，则输出报错信息； tbl_name为表的名字； (列定义|表约束,&hellip;)表示表的其它定义都写在一对括号里，括号里为一个或多个“列定义”或“表约束”，如果有多个列的定义或表约束，则它们之间用逗号隔开。  1 2  CREATE TABLE [IF NOT EXISTS] tbl_name (列定义|表约束,...)   列定义语法  [NOT NULL |NULL]表示空或非空约束，缺省为NULL，即该列的内容允许为空值，NOT NULL则约束该列的内容必须为非空； DEFAULT关键字为列指定缺省值，可以是常量，也可以是表达式； AUTO_INCREMENT指定该列为自增列(如1，2，3，&hellip;)，一般用于自动编号，显然只有数字类型的列才可以定义这一特性； [UNIQUE]指定该列值具有唯一性（但可以有空值-甚至多个空值的存在，如果该列没有定义NOT NULL约束）； PRIMARY KEY指定该列为主码，相当于定义表的实体完整性约束；只有当主码由单属性组成时，才可以这样定义主码（主码由多属性组成时，应当用表约束来定义）； COMMENT用来给列附加一条注释； “REFERENCES”短语为该列定义参照完整性约束，指出该列引用哪个表的哪一列的值，以及违背参照完整性后的具体处理规则（多个规则中选一），具体内容将在随后的练习里再讲解； CHECK(表达式)为列指定“自定义约束”，只有使（表达式）的值为true的数据才允许写入数据库；关键词CONSTRAINT用来为约束命名。  1 2 3 4 5 6 7 8 9  列定义 ::= 列名 数据类型 [NOT NULL | NULL] [DEFAULT {常量 | (表达式)} ] [AUTO_INCREMENT] [UNIQUE [KEY]] [PRIMARY KEY] [COMMENT &#39;列备注&#39;] [REFERENCES tbl_name (col_name) [ON DELETE RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT] [ON UPDATE RESTRICT|CASCADE|SET NULL| NO ACTION|SET DEFAULT]] [[CONSTRAINT [约束名]] CHECK (表达式)]   表约束语法  主码约束以“PK_”打头，后跟表名，一个表只会有一个主码约束； 外码约束以“FK_”打头，后跟表名及列名； CHECK约束以“CK_”打头，后跟表名及列名。  1 2 3 4 5 6 7 8  表约束 ::= [CONSTRAINT [约束名]] | PRIMARY KEY (key_part,.]]></description>
</item>
<item>
    <title>Git基本用法</title>
    <link>https://imcaicai.github.io/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
    <pubDate>Fri, 21 Oct 2022 09:44:35 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
    <description><![CDATA[基本流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # 初始化仓库 git init # 将本地库关联至远程仓库 git remote add origin git@github.com:....github.io.git # 查看当前修改状态  git status # 添加修改过得文件， . 表示所有，也可以指定文件  git add . # &#34;&#34;里面的内容就是提交内容的说明信息  git commit -m &#34;first commit&#34; # 第一次提交方法1 git push -u -f origin main #第一次提交方法2 git pull origin main --allow-unrelated-histories git push -u origin main # 以后提交 git push   其他用法 1.]]></description>
</item>
<item>
    <title>Echo框架入门</title>
    <link>https://imcaicai.github.io/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</link>
    <pubDate>Thu, 20 Oct 2022 19:56:54 &#43;0800</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/echo%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</guid>
    <description><![CDATA[1 路由与控制器 1 路由规则  一条路由规则由：http请求方法 , url路径 , 控制器函数  组成  1.http请求方法
 GET POST PUT DELETE  2.url路径
 静态url路径 带路径参数的url路径 带星号（*）模糊匹配参数的url路径  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 例子1， 静态Url路径, 即不带任何参数的url路径 /users/center /user/101 /food/100 // 例子2，带路径参数的url路径，url路径上面带有参数,参数由冒号（:）跟着一个字符串定义。 // 路径参数值可以是数值，也可以是字符串  //定义参数:id， 可以匹配/user/1, /user/899 /user/xiaoli 这类Url路径 /user/:id //定义参数:id， 可以匹配/food/2, /food/100 /food/apple 这类Url路径 /food/:id //定义参数:type和:page， 可以匹配/foods/2/1, /food/100/25 /food/apple/30 这类Url路径 /foods/:type/:page // 例子3.]]></description>
</item>
<item>
    <title>Go-net标准库应用</title>
    <link>https://imcaicai.github.io/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/</link>
    <pubDate>Thu, 20 Oct 2022 00:00:00 &#43;0000</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/go-net%E6%A0%87%E5%87%86%E5%BA%93%E5%BA%94%E7%94%A8/</guid>
    <description><![CDATA[在go语言标准库中，net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket。
1 服务端 1. 解析地址 在TCP服务端我们需要监听一个TCP地址，因此建立服务端前我们需要生成一个正确的TCP地址，这就需要用到 Resolve 函数。
1 2 3 4 5 6 7 8  // ResolveTCPAddr函数会输出一个TCP连接地址和一个错误信息 func ResolveTCPAddr(network, address string) (*TCPAddr, error) // 解析IP地址 func ResolveIPAddr(net, addr string) (*IPAddr, error) // 解析UDP地址 func ResolveUDPAddr(net, addr string) (*UDPAddr, error) // 解析Unix地址 func ResolveUnixAddr(net, addr string) (*UnixAddr, error)   2. 监听请求 我们可以通过 Listen 方法监听我们解析后的网络地址。
1 2 3 4 5 6 7 8 9 10 11 12  // 监听net类型，地址为laddr的地址 func Listen(net, laddr string) (Listener, error) // 监听TCP地址 func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error) // 监听IP地址 func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error) // 监听UDP地址 func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error) func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error) // 监听Unix地址 func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error) func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)   3.]]></description>
</item>
<item>
    <title>Vision GNN: An Image is Worth Graph of Nodes</title>
    <link>https://imcaicai.github.io/an-image-is-worth-graph-of-nodes/</link>
    <pubDate>Mon, 17 Oct 2022 00:00:00 &#43;0000</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/an-image-is-worth-graph-of-nodes/</guid>
    <description><![CDATA[本文为论文 Vision GNN: An Image is Worth Graph of Nodes 的阅读笔记。
论文下载：https://arxiv.org/abs/2206.00272
引言 网络架构在基于深度学习的计算机视觉中起着关键作用。广泛使用的CNN和 transformer（变换器）将图像视为 grid（网格）或 sequence（序列）结构，这对于捕捉不规则、复杂的物体来说是不灵活的。本文建议将图像表示为一个 graph 结构，并引入一个新的 Vision GNN（ViG）架构来提取视觉任务的图层特征。
文章主要工作：
 介绍了计算机视觉方面的现有模型方法和成果 介绍ViG模型的构建过程及工作原理，为未来的研究提供有用的灵感和经验 通过图像分类和物体检测实验证明了ViG模型在视觉任务中的有效性  1 相关研究 CNN 曾经是计算机视觉中标准的网络结构，但近来 transformer with attention mechanism 、MLP-based 等模型也在不断发展，这些正在将视觉模型推向一个前所未有的高度。
1.1 3种图像结构 不同的网络结构以不同的方式处理输入的图像，通常有grid, sequence ,graph 3种，如下图所示。在 grid  和 sequence 结构中，节点只按空间位置排序；在 graph 结构中，节点是通过其内容连接的，不受局部位置的限制。
CNN 在图像上应用滑动窗口，并引入移位变异性和位置性；最近的 vision transformer 或 MLP 将图像视为 a sequence of patches（补丁序列）。
由于物体形状通常不是规则的四边形，常用的 grid 或 sequence 结构处理起图像来不够灵活，所以在本文中采用 graph 结构。
1.2 3种模型  CNN：曾经是计算机视觉中的主流网络结构，已经成功地应用于各种视觉任务，如图像分类、物体检测和语义分割。CNN模型在过去的十年里发展迅速，代表性的模型包括ResNet、MobileNet和NAS。 Vision transformer：从2020年开始，被引入到视觉任务中，ViT的一些变体开始被提出来以提高视觉任务的性能。主要的改进包括金字塔结，局部注意和位置编码。 MLP：通过专门设计的模块，MLP可以达到有竞争力的性能，并且在一般的视觉任务（如物体检测和分割）上工作。  1.]]></description>
</item>
<item>
    <title>Go基本语法</title>
    <link>https://imcaicai.github.io/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
    <pubDate>Sun, 16 Oct 2022 00:00:00 &#43;0000</pubDate>
    <author>菜菜</author>
    <guid>https://imcaicai.github.io/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
    <description><![CDATA[1 结构  go run helloworld.go：执行Go代码 go build helloworld.go：编译生成二进制文件 ./helloworld：运行 import 声明必须跟在文件的 package 声明之后 Go 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句  函数的左括号 { 必须和 func 函数声明在同一行上，且位于末尾，不能独占一行 在表达式 x+y 中，可在 + 后换行，不能在 + 前换行    2 基础语法 1 2 3 4 5 6  //格式化字符串 var stockcode = 123 var enddate = &#34;2020-12-31&#34; var url = &#34;Code=%d&amp;endDate=%s&#34; var target_url = fmt.Sprintf(url, stockcode, enddate) fmt.Println(target_url)   3 语言类型   布尔型
  数字型]]></description>
</item>
</channel>
</rss>
